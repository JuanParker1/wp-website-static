
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>API Blueprint Archives - APIMatic</title>
	<atom:link href="/blog/category/api-blueprint/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>APIMatic is an API documentation tool that provides a complete set of DX components such as autogenerated SDKs, API portal, API docs, live code samples, and more.</description>
	<lastBuildDate>Sat, 23 Apr 2022 11:52:51 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>

<image>
	<url>/wp-content/uploads/2021/10/cropped-cropped-apimaticio-favicon-1-32x32.png</url>
	<title>API Blueprint Archives - APIMatic</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Top API Specification Trends: 2019-2022</title>
		<link>/blog/2022/03/top-api-specification-trends-2019-2022/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Tue, 15 Mar 2022 13:00:30 +0000</pubDate>
				<category><![CDATA[API Blueprint]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[Postman]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SOAP]]></category>
		<category><![CDATA[OpenApi]]></category>
		<category><![CDATA[Rest API]]></category>
		<category><![CDATA[Soap]]></category>
		<category><![CDATA[Trends]]></category>
		<guid isPermaLink="false">https://apimatic.io/blog/?p=1775</guid>

					<description><![CDATA[<p>Unsurprisingly, the pandemic-ridden era has fueled the rise of APIs in the world. What is more interesting, however, is that with the rise of APIs, a rise in the number of API specification documents has been observed as well. It leads us to believe that more people are adapting to the design-first approach for building [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2022/03/top-api-specification-trends-2019-2022/">Top API Specification Trends: 2019-2022</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class=""><img class="aligncenter wp-image-1844 " src="/wp-content/uploads/2022/04/Top-API-Specification-Trends-01-1024x498.png" alt="" width="726" height="353"></p>
<p class=""><span style="font-weight: 400;">Unsurprisingly, the pandemic-ridden era has fueled the rise of APIs in the world. What is more interesting, however, is that with the rise of APIs, a rise in the number of API specification documents has been observed as well. It leads us to believe that more people are adapting to the design-first approach for building APIs, resulting in intriguing API specification trends.</span></p>
<p class=""><img class="aligncenter wp-image-1786 " src="/wp-content/uploads/2022/04/Yearly-API-Spec-Rise-1024x606.png" alt="" width="631" height="374"></p>
<p class=""><span style="font-weight: 400;">An API specification document is a machine-readable description of an API or service that describes its endpoints, data models, and other related information. In case you are wondering why you need an API description document in the first place, that is an entirely different topic that I have discussed in the blog </span><a href="https://www.apimatic.io/blog/2017/04/why-your-api-needs-machine-readable-description-832e805f6855/"><span style="font-weight: 400;">Why Your API Needs Machine-Readable Description</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">This blog sheds some light on the top API specification trends observed over the past 3 years. You can expect data around which API specification formats were most popular, ones that seem to be emerging over time, and those that are showing signs of imminent death. The trends are based on data collected from APIs imported or transformed by unique users on APIMatic.</span></p>
<h2 class=""><span style="font-weight: 400;">Postman Collections &#8211; Most Popular Input</span></h2>
<p class=""><span style="font-weight: 400;">In the last 3 years, nearly 30,000 users brought only Postman Collections as input into APIMatic either to transform their API specifications to some other format or to generate SDKs/Developer portals. The second-largest number of input API specifications were mainly OpenAPI files.</span></p>
<p class=""><img class="aligncenter wp-image-1778 " src="/wp-content/uploads/2022/04/Imports-1024x620.png" alt="" width="766" height="464"></p>
<p class=""><span style="font-weight: 400;">Many developers test their APIs on Postman which makes it their first choice to store all API-related information. As a next step, if they want to set up a developer experience (DX) platform for their end-users with API documentation and SDKs, it is easier for them to export their stored API information in the form of Postman Collections and use them to generate the required DX kits. This explains the big number of users bringing in Postman Collections as input into APIMatic as well.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">However, the Postman Collection files are structured around making API calls and lack a proper type system to define data more precisely. This makes it a slightly tricky format to deal with when generating good quality SDKs and language-specific documentation, however, you can tackle those issues by following this detailed blog on </span><a href="https://www.apimatic.io/blog/2021/04/curating-postman-collections-to-generate-quality-api-documentation-sdks/"><span style="font-weight: 400;">How to Generate Quality API Documentation &amp; SDKs from Your Postman Collections</span></a><span style="font-weight: 400;">.</span></p>
<h2 class=""><span style="font-weight: 400;">The Rise and Fall of API Specification Formats&nbsp;</span></h2>
<p class=""><span style="font-weight: 400;">In just 3 years, some popular formats have lost some of their fame while others have risen to take the throne.&nbsp;</span></p>
<p class=""><img class="aligncenter wp-image-1777 " src="/wp-content/uploads/2022/04/Emerging-Formats-2-1024x612.png" alt="" width="731" height="437"></p>
<h3 class=""><strong>Insomnia &#8211; An Emerging Format</strong></h3>
<p class=""><span style="font-weight: 400;">Soon after </span><a href="https://konghq.com/blog/kong-acquires-insomnia/"><span style="font-weight: 400;">Kong acquired Insomnia</span></a><span style="font-weight: 400;"> at the end of 2019, the Insomnia specification imports nearly quadrupled in APIMatic. Being quite a newer format, the imports remained quite low as compared to Postman Collections (it being the closest alternative to Insomnia). However, its usage has been increasing steadily ever since.</span></p>
<p class=""><img class="aligncenter wp-image-1779 " src="/wp-content/uploads/2022/04/Insomnia-Growth-1024x603.png" alt="" width="714" height="421"></p>
<h3 class=""><strong>OpenAPI v3.0 Imports Have (Finally) Overtaken v2.0</strong></h3>
<p class=""><span style="font-weight: 400;">Contrary to the API Specifications statistics of </span><a href="https://www.postman.com/state-of-api/api-technologies/"><span style="font-weight: 400;">Postman 2021 State of the API Report</span></a><span style="font-weight: 400;">, APIMatic saw an increase in the number of imports of the newer OpenAPI version v3.0 as compared to v2.0.</span></p>
<p class=""><img class="aligncenter wp-image-1782 " src="/wp-content/uploads/2022/04/OpenAPI-3-vs-OpenAPI-2-1024x608.png" alt="" width="683" height="405"></p>
<p class=""><span style="font-weight: 400;">As can be seen from the graph above, around the start of 2019, the OpenAPI v3.0 imports were initially less than those of v2.0 (also known as Swagger v2.0). Then, they stayed nearly equal for around four months and eventually rose well above them after August 2019. Meanwhile, the imports of v2.0 slowly declined and are expected to continue their downward trend as more and more people adapt to the newer version.&nbsp;</span></p>
<h3 class=""><strong>OpenAPI v3.1 &#8211; Still in Infancy</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI announced its release of the newer version v3.1 in early February 2021 with APIMatic </span><a href="https://docs.apimatic.io/changelog/support-added-for-openapi31/"><span style="font-weight: 400;">releasing support</span></a><span style="font-weight: 400;"> for it in late September.&nbsp;</span></p>
<p class=""><img class="aligncenter wp-image-1783 " src="/wp-content/uploads/2022/04/OpenAPI-3.1-vs-OpenAPI-3.0-Monthly-1024x609.png" alt="" width="688" height="409"><br />
<span style="font-weight: 400;">As was obvious in the case of OpenAPI v3.0 vs v2.0 adoption rates, it takes time for tools and the end-users to adapt to newer versions of specifications. There are still tools out there that continue supporting v2.0 and have yet to add support for OpenAPI v3.0. Even when tools do eventually start supporting a new version, it takes more time for end-users to migrate their existing specifications to it and even more time until they start utilizing the newer features fully.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Therefore, we expect the OpenAPI v3.1 usage to remain quite low for some time. However, with full support for JSON schema and other shiny features, the adoption will open up interesting new possibilities in the future for tools and platforms alike.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">To learn more about APIMatic’s support for OpenAPI v3.1, check out the blog on </span><a href="https://www.apimatic.io/blog/2021/09/migrating-to-and-from-openapi-3-1/"><span style="font-weight: 400;">OpenAPI 3.1 – What’s New, and How to Migrate to/from Other API Specs?</span></a></p>
<h3 class=""><strong>RAML, API Blueprint, WADL are Fading</strong></h3>
<p class=""><img class="aligncenter wp-image-1776 " src="/wp-content/uploads/2022/04/API-Blueprint-WADL-and-RAML-Declining-Imports-1024x606.png" alt="API Blueprint WADL and RAML Declining Imports" width="721" height="427"></p>
<p><span style="font-weight: 400;">In articles that talk about API specifications for REST APIs, OpenAPI/Swagger is usually mentioned the most. However, often you’ll notice API Blueprint, RAML and WADL listed as alternatives as well. All three have been around for quite some time now:</span></p>
<ul class="">
<li style="font-weight: 400;"><span style="font-weight: 400;">RAML’s latest version (v1.0) was released in 2016. It is the primary format used in the Mulesoft Anypoint platform.&nbsp;</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">API Blueprint is the primary format used in the Apiary platform (acquired by Oracle) and was published around 2013.&nbsp;</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">SoapUI users may be familiar with WADL as well, which is a format as old as 2009.&nbsp;</span></li>
</ul>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">
<hr>
</div>
</div>
<p class=""><strong>RAML or OpenAPI on Anypoint Platform &#8211; Now a Choice</strong></p>
<p class=""><span style="font-weight: 400;">RAML v1.0 offers nearly all of the features offered by OpenAPI v3.0. However, while Mulesoft </span><a href="https://blogs.mulesoft.com/dev-guides/open-api-raml-better-together/"><span style="font-weight: 400;">claims that RAML helps you add modularity</span></a><span style="font-weight: 400;"> to your API specification documents, its prime goal is helping define APIs and not modeling API specifications. Mulesoft, therefore, urges users to make use of both OpenAPI and RAML to achieve their goals.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">The trends of the past 3 years talk a little differently and seem to indicate that RAML is slowly losing popularity. RAML may remain a choice for Anypoint users, especially those managing APIs completely on their platform. However, the number of such users seems to be largely decreasing over time as Anypoint itself started </span><a href="https://docs.mulesoft.com/release-notes/platform/oas3"><span style="font-weight: 400;">offering support for OpenAPI v3.0 in 2021</span></a><span style="font-weight: 400;">, and more API management platforms with support for OpenAPI are emerging as well.&nbsp;</span></p>
<p class=""><strong>API Blueprint &#8211; No Longer Actively Maintained</strong></p>
<p class=""><span style="font-weight: 400;">Thanks to Markdown, API Blueprint provided a way to write an API specification document that is more human-friendly. However, the downside of this is a compromise on its ability to be machine-readable. It also lacks some of the advanced features offered by OpenAPI.</span></p>
<p class=""><span style="font-weight: 400;">Interestingly though, API Blueprint is no longer actively maintained since 2019. This may be attributed to Apiary</span><a href="https://blog.apiary.io/OAS-3"><span style="font-weight: 400;"> announcing </span></a><span style="font-weight: 400;">experimental support for OpenAPI v3.0 in early 2019 and can explain why, since then, we are seeing a downward trend in the usage of API Blueprint.&nbsp;&nbsp;</span></p>
<p><strong>WADL &#8211; Best Suited for XML APIs</strong></p>
<p class=""><span style="font-weight: 400;">WADL is an XML-based format for services that work over HTTP. With an increase in REST APIs, JSON has become the most common data exchange format which is best defined using JSON schemas that RAML and OpenAPI support, whereas WADL offers support for only XML schemas.</span></p>
<p class=""><span style="font-weight: 400;">APIs that exchange XML may still benefit from WADL, though based on the trends the number of such APIs seem to be decreasing over time which likely explains the decline in the usage of WADL as well.</span></p>
<h2 class=""><span style="font-weight: 400;">API Specification Transformation Trends</span></h2>
<p class=""><span style="font-weight: 400;">APIMatic offers </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">API Transformer</span></a><span style="font-weight: 400;"> as a free tool to help you transform from one API specification format to another. We support all popular formats including OpenAPI, Postman Collections, RAML, and more.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">I’ll share some interesting trends observed in the API Transformer usage in the 2019-2022 time period. Previously, we conducted similar insights for API Transformer for the years 2017 and 2018. If you are interested, you can check them out here:</span></p>
<ul class="">
<li style="font-weight: 400;"><a href="https://www.apimatic.io/blog/2019/04/api-transformer-insights-2018/"><span style="font-weight: 400;">API Transformer Insights 2018</span></a><span style="font-weight: 400;">&nbsp;</span></li>
<li style="font-weight: 400;"><a href="https://www.apimatic.io/blog/2018/04/a-year-with-api-transformer/"><span style="font-weight: 400;">API Transformer Insights 2017</span></a></li>
</ul>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">
<hr>
</div>
</div>
<h3 class=""><strong>OpenAPI/Swagger v2.0 &#8211; Most Exported Format</strong></h3>
<p class=""><span style="font-weight: 400;">As discussed earlier, the number of OpenAPI v3.0 imports surpassed OpenAPI v2.0 imports in the past 3 years. However, quite surprisingly, the number of OpenAPI v2.0 exports remained quite high as ever, or perhaps more than before. This at least supported the Postman 2021 State of the API Report and my shock was nearly on the same levels as the </span><a href="https://apihandyman.io/we-need-to-talk-openapi-3-is-4-years-old-but-swagger-2-is-still-predominant/"><span style="font-weight: 400;">API Handyman</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><img class="aligncenter wp-image-1781 " src="/wp-content/uploads/2022/04/Most-Exports-1024x611.png" alt="" width="785" height="468"></p>
<p class=""><span style="font-weight: 400;">If you head over to the </span><a href="https://openapi.tools/"><span style="font-weight: 400;">list of popular OpenAPI tools</span></a><span style="font-weight: 400;">, you’ll notice that almost all tools now support OpenAPI v3.0 and there are a large number of tools that don’t even support OpenAPI v2.0 anymore. So, why are people preferring to convert their API specifications to OpenAPI v2.0? Some people are even downgrading from OpenAPI v3.0 to v2.0 (more on that later).&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">While the exact reason is not entirely clear, the apparent reason revolves around the quality of support for OpenAPI v3.0 in tools. OpenAPI v2.0 has been around for much longer than OpenAPI v3.0 so though tools claim to support OpenAPI v3.0 their support for OpenAPI v2.0 may be much more stable and dependable. It is also possible that people are using legacy tools that still only support OpenAPI v2.0.</span></p>
<h3><strong>Top API Specification Transformation Use-Cases</strong></h3>
<p class=""><span style="font-weight: 400;">Over the past three years, some interesting use-cases surrounding API specification transformations have emerged.</span></p>
<p class=""><img class="aligncenter wp-image-1785 " src="/wp-content/uploads/2022/04/Transformation-Use-Cases-1024x615.png" alt="" width="824" height="495"></p>
<p class=""><strong>Postman to OpenAPI</strong></p>
<p class=""><a href="https://learning.postman.com/docs/integrations/available-integrations/apimatic"><span style="font-weight: 400;">Postman&#8217;s APIMatic integration</span></a><span style="font-weight: 400;"> offers its Pro users the ability to convert Postman Collections to any format of their choice. A large number of transformations from Postman Collections can be attributed to that. Nearly 40% of transformations saw users trying to convert their Postman Collection files to OpenAPI.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">As far as the conversion to OpenAPI is concerned, it opens up a large set of tools for Postman users from where they can generate output varying from simple API documentation to feature-packed API developer experience portals with SDKs, live code samples, etc. In other words, converting to OpenAPI helps them manage their APIs better during the later stages of the API lifecycle (e.g. API consumption).</span></p>
<p><strong>OpenAPI v3 to OpenAPI/Swagger v2</strong></p>
<p class=""><span style="font-weight: 400;">15% of the transformations show that users who are already using the newer OpenAPI v3 versions feel the need to downgrade back to the older versions, particularly to OpenAPI v2.0. The only plausible reason seems to be the lack of proper support for OpenAPI v3.0 in tooling that they are looking to use.</span></p>
<p><strong>SOAP to REST</strong></p>
<p class=""><span style="font-weight: 400;">With more benefits, an increasing number of users are looking to migrate their legacy APIs to REST. While the migration is not a single step process, since every SOAP API is accompanied by a WSDL specification/contract, conversion of WSDL to a REST-supporting format (e.g OpenAPI, RAML, etc.) can serve as a starting point. It can give an idea of what the final API can look like.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">In APIMatic, API Transformer offers the </span><a href="https://www.apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest/"><span style="font-weight: 400;">SOAP to REST conversion</span></a><span style="font-weight: 400;">, to its users. Based on the data collected, 8% of the transformations performed by unique users converted their WSDL files to an API specification that supported only REST APIs (e.g. OpenAPI, RAML, WADL, API Blueprint, etc.) in the past three years.</span></p>
<p><strong>Insomnia to Postman</strong></p>
<p class=""><span style="font-weight: 400;">With the increase in Insomnia specification imports, an increase in the number of transformations from Insomnia to Postman Collections has also been observed, constituting about 4% of the total transformations performed by unique users.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Insomnia is the closest alternative to Postman, offering very similar features. However, Postman has been around for quite some time now and hosts a large user base whereas Insomnia is relatively newer. The need to convert between the two formats likely boils down to varying ease of use of both tools as well as personal preference. If, within a single team of your API program you have members who prefer Postman while others prefer Insomnia, then, to ensure smooth collaboration between these members, conversion between the two formats can present itself as a necessary step.</span></p>
<h2 class=""><span style="font-weight: 400;">Invalid API Specifications</span></h2>
<p class=""><span style="font-weight: 400;">Not all the inputs we receive in APIMatic are valid API specification documents. A small portion of them have a few common mistakes or violate the standards one way or another.</span></p>
<h3 class=""><strong>Comparing Success vs Failure Ratio</strong></h3>
<p class=""><img class="aligncenter wp-image-1784 " src="/wp-content/uploads/2022/04/Success-vs-Failure-Ratio-1024x609.png" alt="" width="811" height="482"></p>
<p class=""><span style="font-weight: 400;">Looking at the API specification trends, it is interesting to note that API specification documents that have some form of manual intervention involved showed a greater tendency to be invalid (e.g. RAML, OpenAPI) as compared to API specification documents that are compiled and generated purely by tools (e.g. Postman Collections, Insomnia).&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Out of the total RAML files received by APIMatic in the last three years, nearly 38% had some form of issue. This is in sharp contrast to Postman Collections where out of the total files we received, only 0.99% were invalid.</span></p>
<h3 class=""><strong>Common Causes of Invalidity</strong></h3>
<p class=""><img class="aligncenter wp-image-1780 " src="/wp-content/uploads/2022/04/Invalidity-1024x611.png" alt="" width="715" height="427"></p>
<p class=""><span style="font-weight: 400;">The causes of invalidity vary greatly depending on the format, however, some of the most common ones are listed below:</span></p>
<ol class="">
<li style="font-weight: 400;"><b>Unresolvable references</b><span style="font-weight: 400;"> are the topmost reason for failures. API specifications have different ways to reference other components within the same file or externally. An unresolvable reference is one where the component being referenced either does not exist or exists with a different name or the path to the component is invalid.</span></li>
<li style="font-weight: 400;"><b>Syntax issues</b><span style="font-weight: 400;"> are the second most common reason for failures. A trailing comma in JSON, bad indentation in YAML, or unclosed tag in XML are all examples of invalid syntax.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Often users have specifications where</span><b> types of components do not match</b><span style="font-weight: 400;"> the expected type set by the standards e.g. RAML v1.0 standard sets the type of property </span><code>scopes</code><span style="font-weight: 400;">&nbsp;as a “list” of strings yet plenty of developers declare it as a simple string.</span></li>
</ol>
<p class="">
<p class=""><span style="font-weight: 400;">If you often run into issues like the above, I recommend going through this series of blogs on how to avoid:</span></p>
<ul class="">
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/03/common-mistakes-developers-make-in-their-openapi-3-files/"><span style="font-weight: 400;">Common mistakes developers make in their OpenAPI v3 files</span></a></li>
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/04/common-mistakes-developers-make-in-their-raml-files/"><span style="font-weight: 400;">Common mistakes developers make in their RAML files</span></a></li>
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/09/common-mistakes-developers-make-in-their-api-blueprint-files/"><span style="font-weight: 400;">Common mistakes developers make in their API Blueprint files</span></a></li>
</ul>
<p class="">
<p class=""><span style="font-weight: 400;">In case that doesn’t help, feel free to try some of our </span><a href="https://docs.apimatic.io/api-transformer/transformer-faqs/#troubleshooting"><span style="font-weight: 400;">troubleshooting tips and FAQs</span></a><span style="font-weight: 400;">.&nbsp;</span></p>
<h2 class=""><span style="font-weight: 400;">Conclusion</span></h2>
<p class=""><span style="font-weight: 400;">Recent API specification trends show a mass convergence of the API community towards accepting OpenAPI as the standard for describing REST API services. Postman is expected to continue complementing OpenAPI with its API testing features though it might face some competition from Insomnia in the longer run.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">While new API technologies are emerging like GraphQL, GRPC, and more, REST remains the most popular, with legacy APIs trying to catch up. These trends are expected to play a key role in the evolution of API specifications in 2022 and beyond.&nbsp;</span></p>
</div>
</div>
</div>
</div>
<p>The post <a rel="nofollow" href="/blog/2022/03/top-api-specification-trends-2019-2022/">Top API Specification Trends: 2019-2022</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Common Mistakes Developers Make In Their API Blueprint Files</title>
		<link>/blog/2018/09/common-mistakes-developers-make-in-their-api-blueprint-files/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Wed, 12 Sep 2018 10:53:46 +0000</pubDate>
				<category><![CDATA[API Blueprint]]></category>
		<category><![CDATA[API Documentation]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Blueprint]]></category>
		<category><![CDATA[Api documentation]]></category>
		<category><![CDATA[API Specification]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=570</guid>

					<description><![CDATA[<p>FORMAT: 1A HOST: &#60;a href=&#34;http://hotname.com/&#34;&#62;http://hostname.com&#60;/a&#62; Plenty of developers choose not to make this metadata part of their API description. While not explicitly deemed compulsory by the format owners in the specification, the&#160;FORMAT&#160;part of it is pretty much required. This is because with so many API description formats and various types of Markdown files out there, [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2018/09/common-mistakes-developers-make-in-their-api-blueprint-files/">Common Mistakes Developers Make In Their API Blueprint Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="570" class="elementor elementor-570">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-58a4d220 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="58a4d220" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-32e9f161" data-id="32e9f161" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-2e1f1ad1 elementor-widget elementor-widget-text-editor" data-id="2e1f1ad1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
			<style>/*! elementor - v3.6.4 - 13-04-2022 */
.elementor-widget-text-editor.elementor-drop-cap-view-stacked .elementor-drop-cap{background-color:#818a91;color:#fff}.elementor-widget-text-editor.elementor-drop-cap-view-framed .elementor-drop-cap{color:#818a91;border:3px solid;background-color:transparent}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap{margin-top:8px}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap-letter{width:1em;height:1em}.elementor-widget-text-editor .elementor-drop-cap{float:left;text-align:center;line-height:1;font-size:50px}.elementor-widget-text-editor .elementor-drop-cap-letter{display:inline-block}</style>				<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="aligncenter wp-image-571 size-large" src="/wp-content/uploads/2021/12/1_l1BQ8ERKVn5Yq9k_IHVMPQ-1024x567.png" alt="Common Mistakes Developers Make In Their API Blueprint Files" width="1024" height="567"></p>
</figure>
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="bc4f" class="">If you ever wanted to write a concise and human-friendly API description file, you must have come across <a href="https://apiblueprint.org/documentation/specification.html">API Blueprint</a>. Using Markdown, the simple syntax of this high-level API description format makes it an easier choice for most of the developers out there. Rest assured that though simple, the format is no less powerful than the other popular ones out there like <a href="https://swagger.io/specification/">OpenAPI</a>, <a href="https://raml.org/">RAML</a>, etc. But while their files are mostly generated by tools or from code, API Blueprint, which is promoted as a “design-first” approach to APIs, is for the most part written by hand and is, therefore, more prone to human error.</p>
<p id="bc4f" class="">In this blog, I will analyze each of the mistakes commonly observed in&nbsp;&nbsp;API Blueprint files and highlight their frequency through failure stats collected on <a href="https://www.apimatic.io/transformer">API Transformer</a> over the past year (Aug 2017 — Aug 2018). You may find this blog similar to the ones I wrote previously on common mistakes found <a href="https://apimatic.io/blog/2018/03//common-mistakes-developers-make-in-their-openapi-3-files">in OpenAPI</a>and <a href="https://apimatic.io/blog/2018/04//common-mistakes-developers-make-in-their-raml-files">in RAML</a>.</p>
<blockquote class="">
<p id="c7b3" class="">A shout-out to Kyle and Emmanuel from&nbsp;<a href="https://apiary.io/">Apiary</a>&nbsp;for taking out time to review my blog and providing valuable insights into the future of&nbsp; API Blueprint.</p>
</blockquote>
<h2 id="f205" class="">Absence of Metadata</h2>
<p id="4a13" class="">An&nbsp;&nbsp;API Blueprint file uses Markdown which is a very commonly used documentation format. The <a href="https://apiblueprint.org/documentation/specification.html#def-metadata-section">Metadata section</a> of an&nbsp;&nbsp;API Blueprint file is an important part of it as it differentiates the file from any ordinary Markdown file. This section comprises of the<code>FORMAT</code>&nbsp;and an optional<code>HOST</code>&nbsp;(if the service URL is known) as shown below:</p>
</div>
</div>
</div>
</div>
<!-- /wp:image -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-markdown">FORMAT: 1A
HOST: &lt;a href=&quot;http://hotname.com/&quot;&gt;http://hostname.com&lt;/a&gt;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="2a5d" class="">Plenty of developers choose not to make this metadata part of their API description. While not explicitly deemed compulsory by the format owners in the specification, the&nbsp;<code>FORMAT</code>&nbsp;part of it is pretty much required. This is because with so many API description formats and various types of Markdown files out there, the absence of&nbsp;<code>FORMAT</code> makes it hard to recognize a file as an&nbsp;&nbsp;API Blueprint&nbsp;&nbsp;file. Approx. 24% of the total&nbsp;&nbsp;API Blueprint failures on&nbsp; API Transformer in the past year are attributed to this very issue. Fortunately, Apiary has been considering adding a version identifier to&nbsp;&nbsp;API Blueprint in the future for the elimination of any such identification issues.</p>
<h2 id="c10a" class="">Incorrect Usage of Type System</h2>
<p id="fdd7" class="">Various components of an&nbsp;&nbsp;API Blueprint file make use of a type system e.g. the payload (request/response) attributes, members of a named type, and the URI parameters.&nbsp;&nbsp;API Blueprint&nbsp;&nbsp;generally consists of two kinds of types:</p>
<ol class="">
<li><a href="https://apiblueprint.org/documentation/mson/specification.html#21-base-types">Base types</a> including primitive and structure types.</li>
<li>User-defined types called <a href="https://apiblueprint.org/documentation/mson/specification.html#22-named-types">Named Types</a>&nbsp;(or sometimes referred to simply as Data Structures)</li>
</ol>
<p id="6b95" class=""><a href="https://apiblueprint.org/documentation/mson/specification.html">MSON(Markdown Syntax for Object Notation)</a> lets you define types in great detail in&nbsp;&nbsp;API Blueprint. However, developers do not leverage the power of MSON as much as they should. Let’s have a look into this in more detail below.</p>
<h3 id="2bd5" class="">Using Primitive and Structure types inaccurately</h3>
<p id="d75d" class="">&nbsp;API Blueprint makes available various base types that are listed <a href="https://apiblueprint.org/documentation/mson/specification.html#21-base-types">here</a>. 8% of the API Blueprint&nbsp;failures on API Transformer over the past year occurred because of small mistakes by developers like in trying to:</p>
<ol class="">
<li>Use&nbsp;<code>bool</code>&nbsp;instead of&nbsp;<code>boolean</code></li>
<li>Use&nbsp;<code>numeric</code>&nbsp;instead of&nbsp;<code>number</code></li>
<li>Use&nbsp;<code>list</code>&nbsp;instead of&nbsp;<code>array</code></li>
</ol>
<h3 id="3fe3" class="">Referenced Named types not defined in Data Structures section</h3>
<p id="64ae" class=""><a href="https://apiblueprint.org/documentation/specification.html#def-attributes-section">Attributes</a>&nbsp;and their members (or even those of&nbsp; Named types) can reference other&nbsp; Named types&nbsp;that are required to be defined under the&nbsp;Data Structures section. Several developers reference them without defining them first. Files with such cases constituted 15% of the total API Blueprint&nbsp;files that failed to convert on&nbsp; API Transformer.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-bash">### GET+ Response 200 (application/json) 
+ Attributes (OperationType)</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="f2cb" class="">For example in the above case, it is required that the type used for the response attributes,&nbsp;<code>OperationType</code>, is defined under the&nbsp;<a href="https://apiblueprint.org/documentation/specification.html#def-data-structures">Data Structures</a> section as shown below. If not, you will see an error on the&nbsp;Apiary&nbsp;editor with a message like&nbsp;<code>base type ‘OperationType’ is not defined in the document</code>&nbsp;.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-bash"># Data Structures## OperationType (object)
+ property1 (string, required)</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h3 id="38fb" class="">Confusing the syntax for specifying Attributes Type Definition</h3>
<p id="5aff" class="">The&nbsp;&nbsp;Attributes section&nbsp;&nbsp;helps define a data structure using&nbsp;&nbsp;MSON&nbsp;&nbsp;for the payload, action and resource sections. The attributes can inherit from an existing data structure (say&nbsp;<code>TypeName</code>) and the syntax is generally:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-bash">+ Attributes (TypeName)
      + id (number)</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="39b0">However, a large number of developers sometimes use a syntax like the following:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-markdown">+ Attributes 
   + (TypeName) 
   + id (number)</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="8aa0" class="">This is invalid because in this case the base type is automatically assumed as&nbsp;<code>object</code>&nbsp;and the field<code>+ (TypeName)</code>&nbsp;is considered a&nbsp;<strong>member</strong>&nbsp;of this data structure with type&nbsp;<code>TypeName</code>and a&nbsp;<strong>missing name</strong> (or “no identifier specified” as&nbsp;Apiary editor warns its users). 9% of the total failed&nbsp;&nbsp;API Blueprint&nbsp;&nbsp;conversions on&nbsp; API Transformer&nbsp;were connected to this issue.</p>
<h2 id="5126" class="">Rules Vary for URI Parameters Section</h2>
<p id="f6b1" class="">The&nbsp;&nbsp;URI Parameters section&nbsp;&nbsp;is unique because several rules that apply to this section do not apply to other sections that also make use of the type system. This is because while other sections use MSON, the type system used by this section predates MSON by a few years. The syntax does look similar but it is not equivalent. This can be confusing for most developers which apparently is the cause for the issues I am going to highlight below.&nbsp; Apiary&nbsp;is working to eliminate all such inconsistencies in the future by introducing MSON to both the&nbsp;&nbsp;URI Parameters&nbsp;&nbsp;and&nbsp;&nbsp;Headers&nbsp;&nbsp;section. You can track the progress for it&nbsp;<a href="https://github.com/apiaryio/api-blueprint/issues/286">here</a>.</p>
<h3 id="cb07" class="">URI parameter enum Type Section need explicit Members Type Separator</h3>
<p id="c50b" class="">A lot of users tend to face issues related to enum values not getting loaded properly and this has to do with using the syntax for enum declaration incorrectly. 12% API Blueprint&nbsp;failures on&nbsp;API Transformer&nbsp;were found to be associated with this. Here is why:</p>
<p id="9491" class="">Generally speaking, if you want to enlist the possible member values of an enumeration structure type (say&nbsp;<code>value1</code>&nbsp;and&nbsp;<code>value2)</code>) you may list them in one line as:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-bash">+ memberName: value1, value2 (enum[string])</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="cbcf" class="">Or maybe indent them nicely in a type section:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-bash">+ memberName (enum[string]) 
     + value1 
     + value2</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="24cc" class="">Or maybe add an explicit&nbsp;<a href="https://apiblueprint.org/documentation/mson/specification.html#421-member-type-separator">Members Type separator</a>&nbsp;<code>Members</code>&nbsp;to indicate the section as containing Enum Structure members:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-bash">+ memberName (enum[string])
    + Members
        + value1
        + value2</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="06fe" class="">Although all are valid, the third representation is what is&nbsp;<strong>compulsory</strong> for the&nbsp;URI parameters section&nbsp;and you can confirm this syntax from their official specification documentation as well. So if you choose to not use this representation (and most developers don’t), the values will look in the&nbsp; Apiary&nbsp;editor as:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<figure id="attachment_572" aria-describedby="caption-attachment-572" style="width: 345px" class="wp-caption aligncenter"><img class="wp-image-572" src="/wp-content/uploads/2021/12/1_CoOko1i8iz-0LnvjSgQS6g.png" alt="Parameters view in Apiary editor for invalid representation of enums" width="345" height="140"><figcaption id="caption-attachment-572" class="wp-caption-text">Parameters view in Apiary editor for invalid representation of enums</figcaption></figure>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="7c5d" class="">With the correct representation, you will see the editor recognize the set of values correctly:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<figure id="attachment_573" aria-describedby="caption-attachment-573" style="width: 342px" class="wp-caption aligncenter"><img class="wp-image-573" src="/wp-content/uploads/2021/12/1_t288KKfqA4ZlgZyLxKb8NQ.png" alt="Parameters view In Apiary editor for valid representation of enums" width="342" height="138"><figcaption id="caption-attachment-573" class="wp-caption-text">Parameters view In Apiary editor for valid representation of enums</figcaption></figure>
<figcaption></figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h3 id="3132" class="">Open-Ended Type System</h3>
<p id="4e66" class="">For the&nbsp;&nbsp;URI parameters, it is a good practice to use only the primitive types and usage of complex types for&nbsp; URI parameters is, therefore, seen very rarely. But developers feel the need to use different types based on their API design. And most of them do not define these types explicitly (like under the <a href="https://apiblueprint.org/documentation/specification.html#def-data-structures">Data Structures section</a>) which then creates trouble when using various tools.</p>
<p id="4379" class="">The specification for&nbsp;&nbsp;API Blueprint&nbsp;&nbsp;poses no strictness as such for the type specification of these parameters because it simply says:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-bash">&lt;type&gt; is the optional parameter type as expected by the API (e.g. &quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;). &quot;string&quot; is the default.</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="1d80" class="">So if you choose to use any random type in this section (e.g.&nbsp;<code>set</code>,&nbsp;<code>json</code>, etc. ), the official editor won’t complain. However, this open-endedness, while suitable for documentation purposes, is not suited for tools like APIMatic that depend on these API description files for generation of client libraries and developer experience portals. This is because generation requires specific details of all types and any types other than the primitive ones cannot be comprehended by the tool unless explicitly defined. Hence, the largest portion of&nbsp;&nbsp;API Blueprint failures on API Transformer (31%) pertained to this open-endedness.</p>
<h2 id="af61" class="">Conclusion</h2>
<p id="2f0a" class="">&nbsp;API Blueprint is a widely used format with a vast number of features and tooling available. MSON empowers it further through a type system that uses Markdown. In order to utilize MSON to its true potential, it is important to understand it fully. The learning curve for it is high and the specification feels a little overwhelming which is probably why most people tend to shy away from it. Perhaps providing more examples in the specification will help clear some of the ambiguities that developers face and allow for lesser mistakes.</p>
<p id="544a" class="">Also since Apiary&nbsp;is working on improving&nbsp;API Blueprint in its future releases, we can expect lesser inconsistencies and, therefore, lesser issues in the description files. Meanwhile, you can head over to API Transformer&nbsp;to improve your existing API Blueprint&nbsp;file or to convert to other formats for free.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2018/09/common-mistakes-developers-make-in-their-api-blueprint-files/">Common Mistakes Developers Make In Their API Blueprint Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
