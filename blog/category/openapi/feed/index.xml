
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>OpenAPI Archives - APIMatic</title>
	<atom:link href="/blog/category/openapi/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>APIMatic is an API documentation tool that provides a complete set of DX components such as autogenerated SDKs, API portal, API docs, live code samples, and more.</description>
	<lastBuildDate>Sun, 24 Apr 2022 00:36:09 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>

<image>
	<url>/wp-content/uploads/2021/10/cropped-cropped-apimaticio-favicon-1-32x32.png</url>
	<title>OpenAPI Archives - APIMatic</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Top API Specification Trends: 2019-2022</title>
		<link>/blog/2022/03/top-api-specification-trends-2019-2022/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Tue, 15 Mar 2022 13:00:30 +0000</pubDate>
				<category><![CDATA[API Blueprint]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[Postman]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SOAP]]></category>
		<category><![CDATA[OpenApi]]></category>
		<category><![CDATA[Rest API]]></category>
		<category><![CDATA[Soap]]></category>
		<category><![CDATA[Trends]]></category>
		<guid isPermaLink="false">https://apimatic.io/blog/?p=1775</guid>

					<description><![CDATA[<p>Unsurprisingly, the pandemic-ridden era has fueled the rise of APIs in the world. What is more interesting, however, is that with the rise of APIs, a rise in the number of API specification documents has been observed as well. It leads us to believe that more people are adapting to the design-first approach for building [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2022/03/top-api-specification-trends-2019-2022/">Top API Specification Trends: 2019-2022</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class=""><img class="aligncenter wp-image-1844 " src="/wp-content/uploads/2022/04/Top-API-Specification-Trends-01-1024x498.png" alt="" width="726" height="353"></p>
<p class=""><span style="font-weight: 400;">Unsurprisingly, the pandemic-ridden era has fueled the rise of APIs in the world. What is more interesting, however, is that with the rise of APIs, a rise in the number of API specification documents has been observed as well. It leads us to believe that more people are adapting to the design-first approach for building APIs, resulting in intriguing API specification trends.</span></p>
<p class=""><img class="aligncenter wp-image-1786 " src="/wp-content/uploads/2022/04/Yearly-API-Spec-Rise-1024x606.png" alt="" width="631" height="374"></p>
<p class=""><span style="font-weight: 400;">An API specification document is a machine-readable description of an API or service that describes its endpoints, data models, and other related information. In case you are wondering why you need an API description document in the first place, that is an entirely different topic that I have discussed in the blog </span><a href="https://www.apimatic.io/blog/2017/04/why-your-api-needs-machine-readable-description-832e805f6855/"><span style="font-weight: 400;">Why Your API Needs Machine-Readable Description</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">This blog sheds some light on the top API specification trends observed over the past 3 years. You can expect data around which API specification formats were most popular, ones that seem to be emerging over time, and those that are showing signs of imminent death. The trends are based on data collected from APIs imported or transformed by unique users on APIMatic.</span></p>
<h2 class=""><span style="font-weight: 400;">Postman Collections &#8211; Most Popular Input</span></h2>
<p class=""><span style="font-weight: 400;">In the last 3 years, nearly 30,000 users brought only Postman Collections as input into APIMatic either to transform their API specifications to some other format or to generate SDKs/Developer portals. The second-largest number of input API specifications were mainly OpenAPI files.</span></p>
<p class=""><img class="aligncenter wp-image-1778 " src="/wp-content/uploads/2022/04/Imports-1024x620.png" alt="" width="766" height="464"></p>
<p class=""><span style="font-weight: 400;">Many developers test their APIs on Postman which makes it their first choice to store all API-related information. As a next step, if they want to set up a developer experience (DX) platform for their end-users with API documentation and SDKs, it is easier for them to export their stored API information in the form of Postman Collections and use them to generate the required DX kits. This explains the big number of users bringing in Postman Collections as input into APIMatic as well.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">However, the Postman Collection files are structured around making API calls and lack a proper type system to define data more precisely. This makes it a slightly tricky format to deal with when generating good quality SDKs and language-specific documentation, however, you can tackle those issues by following this detailed blog on </span><a href="https://www.apimatic.io/blog/2021/04/curating-postman-collections-to-generate-quality-api-documentation-sdks/"><span style="font-weight: 400;">How to Generate Quality API Documentation &amp; SDKs from Your Postman Collections</span></a><span style="font-weight: 400;">.</span></p>
<h2 class=""><span style="font-weight: 400;">The Rise and Fall of API Specification Formats&nbsp;</span></h2>
<p class=""><span style="font-weight: 400;">In just 3 years, some popular formats have lost some of their fame while others have risen to take the throne.&nbsp;</span></p>
<p class=""><img class="aligncenter wp-image-1777 " src="/wp-content/uploads/2022/04/Emerging-Formats-2-1024x612.png" alt="" width="731" height="437"></p>
<h3 class=""><strong>Insomnia &#8211; An Emerging Format</strong></h3>
<p class=""><span style="font-weight: 400;">Soon after </span><a href="https://konghq.com/blog/kong-acquires-insomnia/"><span style="font-weight: 400;">Kong acquired Insomnia</span></a><span style="font-weight: 400;"> at the end of 2019, the Insomnia specification imports nearly quadrupled in APIMatic. Being quite a newer format, the imports remained quite low as compared to Postman Collections (it being the closest alternative to Insomnia). However, its usage has been increasing steadily ever since.</span></p>
<p class=""><img class="aligncenter wp-image-1779 " src="/wp-content/uploads/2022/04/Insomnia-Growth-1024x603.png" alt="" width="714" height="421"></p>
<h3 class=""><strong>OpenAPI v3.0 Imports Have (Finally) Overtaken v2.0</strong></h3>
<p class=""><span style="font-weight: 400;">Contrary to the API Specifications statistics of </span><a href="https://www.postman.com/state-of-api/api-technologies/"><span style="font-weight: 400;">Postman 2021 State of the API Report</span></a><span style="font-weight: 400;">, APIMatic saw an increase in the number of imports of the newer OpenAPI version v3.0 as compared to v2.0.</span></p>
<p class=""><img class="aligncenter wp-image-1782 " src="/wp-content/uploads/2022/04/OpenAPI-3-vs-OpenAPI-2-1024x608.png" alt="" width="683" height="405"></p>
<p class=""><span style="font-weight: 400;">As can be seen from the graph above, around the start of 2019, the OpenAPI v3.0 imports were initially less than those of v2.0 (also known as Swagger v2.0). Then, they stayed nearly equal for around four months and eventually rose well above them after August 2019. Meanwhile, the imports of v2.0 slowly declined and are expected to continue their downward trend as more and more people adapt to the newer version.&nbsp;</span></p>
<h3 class=""><strong>OpenAPI v3.1 &#8211; Still in Infancy</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI announced its release of the newer version v3.1 in early February 2021 with APIMatic </span><a href="https://docs.apimatic.io/changelog/support-added-for-openapi31/"><span style="font-weight: 400;">releasing support</span></a><span style="font-weight: 400;"> for it in late September.&nbsp;</span></p>
<p class=""><img class="aligncenter wp-image-1783 " src="/wp-content/uploads/2022/04/OpenAPI-3.1-vs-OpenAPI-3.0-Monthly-1024x609.png" alt="" width="688" height="409"><br />
<span style="font-weight: 400;">As was obvious in the case of OpenAPI v3.0 vs v2.0 adoption rates, it takes time for tools and the end-users to adapt to newer versions of specifications. There are still tools out there that continue supporting v2.0 and have yet to add support for OpenAPI v3.0. Even when tools do eventually start supporting a new version, it takes more time for end-users to migrate their existing specifications to it and even more time until they start utilizing the newer features fully.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Therefore, we expect the OpenAPI v3.1 usage to remain quite low for some time. However, with full support for JSON schema and other shiny features, the adoption will open up interesting new possibilities in the future for tools and platforms alike.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">To learn more about APIMatic’s support for OpenAPI v3.1, check out the blog on </span><a href="https://www.apimatic.io/blog/2021/09/migrating-to-and-from-openapi-3-1/"><span style="font-weight: 400;">OpenAPI 3.1 – What’s New, and How to Migrate to/from Other API Specs?</span></a></p>
<h3 class=""><strong>RAML, API Blueprint, WADL are Fading</strong></h3>
<p class=""><img class="aligncenter wp-image-1776 " src="/wp-content/uploads/2022/04/API-Blueprint-WADL-and-RAML-Declining-Imports-1024x606.png" alt="API Blueprint WADL and RAML Declining Imports" width="721" height="427"></p>
<p><span style="font-weight: 400;">In articles that talk about API specifications for REST APIs, OpenAPI/Swagger is usually mentioned the most. However, often you’ll notice API Blueprint, RAML and WADL listed as alternatives as well. All three have been around for quite some time now:</span></p>
<ul class="">
<li style="font-weight: 400;"><span style="font-weight: 400;">RAML’s latest version (v1.0) was released in 2016. It is the primary format used in the Mulesoft Anypoint platform.&nbsp;</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">API Blueprint is the primary format used in the Apiary platform (acquired by Oracle) and was published around 2013.&nbsp;</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">SoapUI users may be familiar with WADL as well, which is a format as old as 2009.&nbsp;</span></li>
</ul>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">
<hr>
</div>
</div>
<p class=""><strong>RAML or OpenAPI on Anypoint Platform &#8211; Now a Choice</strong></p>
<p class=""><span style="font-weight: 400;">RAML v1.0 offers nearly all of the features offered by OpenAPI v3.0. However, while Mulesoft </span><a href="https://blogs.mulesoft.com/dev-guides/open-api-raml-better-together/"><span style="font-weight: 400;">claims that RAML helps you add modularity</span></a><span style="font-weight: 400;"> to your API specification documents, its prime goal is helping define APIs and not modeling API specifications. Mulesoft, therefore, urges users to make use of both OpenAPI and RAML to achieve their goals.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">The trends of the past 3 years talk a little differently and seem to indicate that RAML is slowly losing popularity. RAML may remain a choice for Anypoint users, especially those managing APIs completely on their platform. However, the number of such users seems to be largely decreasing over time as Anypoint itself started </span><a href="https://docs.mulesoft.com/release-notes/platform/oas3"><span style="font-weight: 400;">offering support for OpenAPI v3.0 in 2021</span></a><span style="font-weight: 400;">, and more API management platforms with support for OpenAPI are emerging as well.&nbsp;</span></p>
<p class=""><strong>API Blueprint &#8211; No Longer Actively Maintained</strong></p>
<p class=""><span style="font-weight: 400;">Thanks to Markdown, API Blueprint provided a way to write an API specification document that is more human-friendly. However, the downside of this is a compromise on its ability to be machine-readable. It also lacks some of the advanced features offered by OpenAPI.</span></p>
<p class=""><span style="font-weight: 400;">Interestingly though, API Blueprint is no longer actively maintained since 2019. This may be attributed to Apiary</span><a href="https://blog.apiary.io/OAS-3"><span style="font-weight: 400;"> announcing </span></a><span style="font-weight: 400;">experimental support for OpenAPI v3.0 in early 2019 and can explain why, since then, we are seeing a downward trend in the usage of API Blueprint.&nbsp;&nbsp;</span></p>
<p><strong>WADL &#8211; Best Suited for XML APIs</strong></p>
<p class=""><span style="font-weight: 400;">WADL is an XML-based format for services that work over HTTP. With an increase in REST APIs, JSON has become the most common data exchange format which is best defined using JSON schemas that RAML and OpenAPI support, whereas WADL offers support for only XML schemas.</span></p>
<p class=""><span style="font-weight: 400;">APIs that exchange XML may still benefit from WADL, though based on the trends the number of such APIs seem to be decreasing over time which likely explains the decline in the usage of WADL as well.</span></p>
<h2 class=""><span style="font-weight: 400;">API Specification Transformation Trends</span></h2>
<p class=""><span style="font-weight: 400;">APIMatic offers </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">API Transformer</span></a><span style="font-weight: 400;"> as a free tool to help you transform from one API specification format to another. We support all popular formats including OpenAPI, Postman Collections, RAML, and more.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">I’ll share some interesting trends observed in the API Transformer usage in the 2019-2022 time period. Previously, we conducted similar insights for API Transformer for the years 2017 and 2018. If you are interested, you can check them out here:</span></p>
<ul class="">
<li style="font-weight: 400;"><a href="https://www.apimatic.io/blog/2019/04/api-transformer-insights-2018/"><span style="font-weight: 400;">API Transformer Insights 2018</span></a><span style="font-weight: 400;">&nbsp;</span></li>
<li style="font-weight: 400;"><a href="https://www.apimatic.io/blog/2018/04/a-year-with-api-transformer/"><span style="font-weight: 400;">API Transformer Insights 2017</span></a></li>
</ul>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">
<hr>
</div>
</div>
<h3 class=""><strong>OpenAPI/Swagger v2.0 &#8211; Most Exported Format</strong></h3>
<p class=""><span style="font-weight: 400;">As discussed earlier, the number of OpenAPI v3.0 imports surpassed OpenAPI v2.0 imports in the past 3 years. However, quite surprisingly, the number of OpenAPI v2.0 exports remained quite high as ever, or perhaps more than before. This at least supported the Postman 2021 State of the API Report and my shock was nearly on the same levels as the </span><a href="https://apihandyman.io/we-need-to-talk-openapi-3-is-4-years-old-but-swagger-2-is-still-predominant/"><span style="font-weight: 400;">API Handyman</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><img class="aligncenter wp-image-1781 " src="/wp-content/uploads/2022/04/Most-Exports-1024x611.png" alt="" width="785" height="468"></p>
<p class=""><span style="font-weight: 400;">If you head over to the </span><a href="https://openapi.tools/"><span style="font-weight: 400;">list of popular OpenAPI tools</span></a><span style="font-weight: 400;">, you’ll notice that almost all tools now support OpenAPI v3.0 and there are a large number of tools that don’t even support OpenAPI v2.0 anymore. So, why are people preferring to convert their API specifications to OpenAPI v2.0? Some people are even downgrading from OpenAPI v3.0 to v2.0 (more on that later).&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">While the exact reason is not entirely clear, the apparent reason revolves around the quality of support for OpenAPI v3.0 in tools. OpenAPI v2.0 has been around for much longer than OpenAPI v3.0 so though tools claim to support OpenAPI v3.0 their support for OpenAPI v2.0 may be much more stable and dependable. It is also possible that people are using legacy tools that still only support OpenAPI v2.0.</span></p>
<h3><strong>Top API Specification Transformation Use-Cases</strong></h3>
<p class=""><span style="font-weight: 400;">Over the past three years, some interesting use-cases surrounding API specification transformations have emerged.</span></p>
<p class=""><img class="aligncenter wp-image-1785 " src="/wp-content/uploads/2022/04/Transformation-Use-Cases-1024x615.png" alt="" width="824" height="495"></p>
<p class=""><strong>Postman to OpenAPI</strong></p>
<p class=""><a href="https://learning.postman.com/docs/integrations/available-integrations/apimatic"><span style="font-weight: 400;">Postman&#8217;s APIMatic integration</span></a><span style="font-weight: 400;"> offers its Pro users the ability to convert Postman Collections to any format of their choice. A large number of transformations from Postman Collections can be attributed to that. Nearly 40% of transformations saw users trying to convert their Postman Collection files to OpenAPI.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">As far as the conversion to OpenAPI is concerned, it opens up a large set of tools for Postman users from where they can generate output varying from simple API documentation to feature-packed API developer experience portals with SDKs, live code samples, etc. In other words, converting to OpenAPI helps them manage their APIs better during the later stages of the API lifecycle (e.g. API consumption).</span></p>
<p><strong>OpenAPI v3 to OpenAPI/Swagger v2</strong></p>
<p class=""><span style="font-weight: 400;">15% of the transformations show that users who are already using the newer OpenAPI v3 versions feel the need to downgrade back to the older versions, particularly to OpenAPI v2.0. The only plausible reason seems to be the lack of proper support for OpenAPI v3.0 in tooling that they are looking to use.</span></p>
<p><strong>SOAP to REST</strong></p>
<p class=""><span style="font-weight: 400;">With more benefits, an increasing number of users are looking to migrate their legacy APIs to REST. While the migration is not a single step process, since every SOAP API is accompanied by a WSDL specification/contract, conversion of WSDL to a REST-supporting format (e.g OpenAPI, RAML, etc.) can serve as a starting point. It can give an idea of what the final API can look like.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">In APIMatic, API Transformer offers the </span><a href="https://www.apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest/"><span style="font-weight: 400;">SOAP to REST conversion</span></a><span style="font-weight: 400;">, to its users. Based on the data collected, 8% of the transformations performed by unique users converted their WSDL files to an API specification that supported only REST APIs (e.g. OpenAPI, RAML, WADL, API Blueprint, etc.) in the past three years.</span></p>
<p><strong>Insomnia to Postman</strong></p>
<p class=""><span style="font-weight: 400;">With the increase in Insomnia specification imports, an increase in the number of transformations from Insomnia to Postman Collections has also been observed, constituting about 4% of the total transformations performed by unique users.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Insomnia is the closest alternative to Postman, offering very similar features. However, Postman has been around for quite some time now and hosts a large user base whereas Insomnia is relatively newer. The need to convert between the two formats likely boils down to varying ease of use of both tools as well as personal preference. If, within a single team of your API program you have members who prefer Postman while others prefer Insomnia, then, to ensure smooth collaboration between these members, conversion between the two formats can present itself as a necessary step.</span></p>
<h2 class=""><span style="font-weight: 400;">Invalid API Specifications</span></h2>
<p class=""><span style="font-weight: 400;">Not all the inputs we receive in APIMatic are valid API specification documents. A small portion of them have a few common mistakes or violate the standards one way or another.</span></p>
<h3 class=""><strong>Comparing Success vs Failure Ratio</strong></h3>
<p class=""><img class="aligncenter wp-image-1784 " src="/wp-content/uploads/2022/04/Success-vs-Failure-Ratio-1024x609.png" alt="" width="811" height="482"></p>
<p class=""><span style="font-weight: 400;">Looking at the API specification trends, it is interesting to note that API specification documents that have some form of manual intervention involved showed a greater tendency to be invalid (e.g. RAML, OpenAPI) as compared to API specification documents that are compiled and generated purely by tools (e.g. Postman Collections, Insomnia).&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Out of the total RAML files received by APIMatic in the last three years, nearly 38% had some form of issue. This is in sharp contrast to Postman Collections where out of the total files we received, only 0.99% were invalid.</span></p>
<h3 class=""><strong>Common Causes of Invalidity</strong></h3>
<p class=""><img class="aligncenter wp-image-1780 " src="/wp-content/uploads/2022/04/Invalidity-1024x611.png" alt="" width="715" height="427"></p>
<p class=""><span style="font-weight: 400;">The causes of invalidity vary greatly depending on the format, however, some of the most common ones are listed below:</span></p>
<ol class="">
<li style="font-weight: 400;"><b>Unresolvable references</b><span style="font-weight: 400;"> are the topmost reason for failures. API specifications have different ways to reference other components within the same file or externally. An unresolvable reference is one where the component being referenced either does not exist or exists with a different name or the path to the component is invalid.</span></li>
<li style="font-weight: 400;"><b>Syntax issues</b><span style="font-weight: 400;"> are the second most common reason for failures. A trailing comma in JSON, bad indentation in YAML, or unclosed tag in XML are all examples of invalid syntax.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Often users have specifications where</span><b> types of components do not match</b><span style="font-weight: 400;"> the expected type set by the standards e.g. RAML v1.0 standard sets the type of property </span><code>scopes</code><span style="font-weight: 400;">&nbsp;as a “list” of strings yet plenty of developers declare it as a simple string.</span></li>
</ol>
<p class="">
<p class=""><span style="font-weight: 400;">If you often run into issues like the above, I recommend going through this series of blogs on how to avoid:</span></p>
<ul class="">
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/03/common-mistakes-developers-make-in-their-openapi-3-files/"><span style="font-weight: 400;">Common mistakes developers make in their OpenAPI v3 files</span></a></li>
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/04/common-mistakes-developers-make-in-their-raml-files/"><span style="font-weight: 400;">Common mistakes developers make in their RAML files</span></a></li>
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/09/common-mistakes-developers-make-in-their-api-blueprint-files/"><span style="font-weight: 400;">Common mistakes developers make in their API Blueprint files</span></a></li>
</ul>
<p class="">
<p class=""><span style="font-weight: 400;">In case that doesn’t help, feel free to try some of our </span><a href="https://docs.apimatic.io/api-transformer/transformer-faqs/#troubleshooting"><span style="font-weight: 400;">troubleshooting tips and FAQs</span></a><span style="font-weight: 400;">.&nbsp;</span></p>
<h2 class=""><span style="font-weight: 400;">Conclusion</span></h2>
<p class=""><span style="font-weight: 400;">Recent API specification trends show a mass convergence of the API community towards accepting OpenAPI as the standard for describing REST API services. Postman is expected to continue complementing OpenAPI with its API testing features though it might face some competition from Insomnia in the longer run.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">While new API technologies are emerging like GraphQL, GRPC, and more, REST remains the most popular, with legacy APIs trying to catch up. These trends are expected to play a key role in the evolution of API specifications in 2022 and beyond.&nbsp;</span></p>
</div>
</div>
</div>
</div>
<p>The post <a rel="nofollow" href="/blog/2022/03/top-api-specification-trends-2019-2022/">Top API Specification Trends: 2019-2022</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>OpenAPI 3.1 &#8211; What&#8217;s New, and How to Migrate to/from Other API Specs?</title>
		<link>/blog/2021/09/introducing-openapi-3-1-support-in-apimatic/</link>
		
		<dc:creator><![CDATA[Ali Raza]]></dc:creator>
		<pubDate>Tue, 21 Sep 2021 12:40:43 +0000</pubDate>
				<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[APIMATIC]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[Releases]]></category>
		<category><![CDATA[API Specification]]></category>
		<category><![CDATA[Api Specs]]></category>
		<category><![CDATA[APIMatic Supported Specs]]></category>
		<category><![CDATA[OpenAPI 3.1]]></category>
		<guid isPermaLink="false">https://apimatic.io/blog/?p=1461</guid>

					<description><![CDATA[<p>The OpenAPI Initiative announced the latest API specification format OpenAPI 3.1 earlier this year. OpenAPI 3.1 introduces multiple new functionalities and improvements compared to the previous OpenAPI versions, which is why this upgrade is expected to have a higher adoption rate. We are excited to announce the support for OpenAPI 3.1 as APIMatic’s latest supported [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2021/09/introducing-openapi-3-1-support-in-apimatic/">OpenAPI 3.1 &#8211; What&#8217;s New, and How to Migrate to/from Other API Specs?</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1461" class="elementor elementor-1461">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-2a51f48e elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="2a51f48e" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-30d8c0c6" data-id="30d8c0c6" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-6b60005c elementor-widget elementor-widget-text-editor" data-id="6b60005c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
			<style>/*! elementor - v3.6.4 - 13-04-2022 */
.elementor-widget-text-editor.elementor-drop-cap-view-stacked .elementor-drop-cap{background-color:#818a91;color:#fff}.elementor-widget-text-editor.elementor-drop-cap-view-framed .elementor-drop-cap{color:#818a91;border:3px solid;background-color:transparent}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap{margin-top:8px}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap-letter{width:1em;height:1em}.elementor-widget-text-editor .elementor-drop-cap{float:left;text-align:center;line-height:1;font-size:50px}.elementor-widget-text-editor .elementor-drop-cap-letter{display:inline-block}</style>				<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12" data-wp-editing="1">
<p class=""><img class="aligncenter wp-image-1474" src="/wp-content/uploads/2021/12/introducing-openapi-3-1-in-apimatic-1024x538.png" alt="OpenAPI 3.1 - What's New and How to Migrate to/from Other API Specs? " width="535" height="281"></p>
<p class=""><span style="font-weight: 400;">The OpenAPI Initiative </span><a href="https://www.openapis.org/blog/2021/02/18/openapi-specification-3-1-released"><span style="font-weight: 400;">announced</span></a> <span style="font-weight: 400;">the latest API specification format </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md"><span style="font-weight: 400;">OpenAPI 3.1</span></a><span style="font-weight: 400;"> earlier this year. OpenAPI 3.1 introduces multiple new functionalities and improvements compared to the previous OpenAPI versions, which is why this upgrade is expected to have a higher adoption rate.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">We are excited to announce the support for OpenAPI 3.1 as APIMatic’s latest supported API specification format, which can be used throughout </span><a href="https://www.apimatic.io/"><span style="font-weight: 400;">APIMatic</span></a><span style="font-weight: 400;">’s solutions like API transformation, API Portal generation, and SDK generation.</span></p>

<h2 class=""><strong>How Does APIMatic Support OpenAPI 3.1?</strong></h2>
<p class=""><span style="font-weight: 400;">OpenAPI 3.1 can be used in APIMatic to perform any API transformation or to generate API portals and SDKs.</span></p>

<h3 class=""><strong>API Specification Transformation</strong></h3>
<p class=""><span style="font-weight: 400;">APIMatic supports transformations between different API specification formats. If you haven’t jumped on the OpenAPI 3.1 bandwagon yet, you can transform your existing API definition file into OAS 3.1, or convert an OpenAPI 3.1 file to any </span><a href="https://www.apimatic.io/transformer/#supported-formats"><span style="font-weight: 400;">supported format</span></a><span style="font-weight: 400;">.</span></p>

<h3 class=""><strong>API Portal and SDK Generation</strong></h3>
<p class=""><span style="font-weight: 400;">APIMatic’s Code Generator and Docs Generator also support OpenAPI 3.1 definition files. You can import your OpenAPI 3.1 file so as to generate the developer-friendly </span><a href="https://www.apimatic.io/developer-experience-portal/"><span style="font-weight: 400;">API Portal</span></a> <span style="font-weight: 400;">or to generate feature-rich SDKs in any </span><a href="https://docs.apimatic.io/generate-sdks/supported-sdk-version-dependencies/#supported-sdk-language-versions"><span style="font-weight: 400;">language supported</span></a> <span style="font-weight: 400;">by APIMatic.</span></p>

<h2 class=""><strong>Behind the Scenes of Mapping OpenAPI 3.0 to OpenAPI 3.1 in APIMatic</strong></h2>
<p class=""><span style="font-weight: 400;">Let’s dive in to see the process of how each component of OpenAPI 3.0 is actually mapped to the corresponding component in OpenAPI 3.1 with </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">APIMatic Transformer</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">The major difference between both formats is related to the </span><b>Schema Object</b><span style="font-weight: 400;">. Previously, the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject"><span style="font-weight: 400;">OpenAPI 3.0 Schema Object</span></a> <span style="font-weight: 400;">was an extended subset of JSON Schema Specification </span><a href="http://json-schema.org/"><span style="font-weight: 400;">Wright Draft 00</span></a><span style="font-weight: 400;">, however, the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schemaObject"><span style="font-weight: 400;">OpenAPI 3.1 Schema Object</span></a><span style="font-weight: 400;"> is a superset of JSON Schema Specification </span><a href="https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00"><span style="font-weight: 400;">Draft 2020-12</span></a><span style="font-weight: 400;"> by default</span><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">Having said that,</span><span style="font-weight: 400;"> you can also use any valid JSON Schema as a Schema Object in OpenAPI 3.1 with </span><a href="http://json-schema.org/understanding-json-schema/reference/schema.html#:~:text=A%20version%20of%20JSON%20Schema,new%20dialect%20of%20JSON%20Schema."><span style="font-weight: 400;">JSON Schema Dialect</span></a><span style="font-weight: 400;"> declared in either JSON Schema or in </span><code>jsonSchemaDialect</code><span style="font-weight: 400;">&nbsp;field in the root OpenAPI 3.1 specification, for that matter.</span></p>
<span style="font-weight: 400;">Now let’s start looking into the mapping of some of the most widely used components of OpenAPI 3.0 to OpenAPI 3.1 one by one:</span>
<h3 class=""><strong>Root Object</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI 3.1 has two additional root components </span><code>jsonSchemaDialect</code><span style="font-weight: 400;"> and </span><code>webhooks</code><span style="font-weight: 400;">&nbsp;as shown in the diagram below.</span></p>
<p class=""><span style="font-weight: 400;">APIMatic Transformer sets <code>jsonSchemaDialect</code> </span><span style="font-weight: 400;">&nbsp;to “</span><a href="https://json-schema.org/draft/2020-12/schema"> <code>https://json-schema.org/draft/2020-12/schema</code></a><span style="font-weight: 400;">” in the exported OpenAPI 3.1 file since the exported file always contains Schema Objects which conform to JSON Schema Specification Draft 2020-12.</span></p>


<figure id="attachment_1467" aria-describedby="caption-attachment-1467" style="width: 581px" class="wp-caption aligncenter"><img class="wp-image-1467 " src="/wp-content/uploads/2021/12/root-objects.png" alt="Difference between Root Objects of OpenAPI 3.0 and OpenAPI 3.1" width="581" height="418"><figcaption id="caption-attachment-1467" class="wp-caption-text">Difference between Root Objects of OpenAPI 3.0 and OpenAPI 3.1</figcaption></figure>
<h3 class=""><strong>Info Object</strong></h3>
<p class=""><span style="font-weight: 400;">The </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#infoObject"><span style="font-weight: 400;">Info Object in OpenAPI 3.1</span></a><span style="font-weight: 400;"> is a superset of the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#infoObject"><span style="font-weight: 400;">Info Object in OpenAPI 3.0</span></a><span style="font-weight: 400;"> having an additional </span><span style="font-weight: 400;">summary</span><span style="font-weight: 400;"> field. The APIMatic Transformer maps the Info Object’s data from OpenAPI 3.0 to OpenAPI 3.1.</span></p>
<p class=""><span style="font-weight: 400;">Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1</span></p>
<p class="mod-reset"><img class="aligncenter wp-image-1466 " src="/wp-content/uploads/2021/12/info-object-1.png" alt="Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1" width="611" height="330"></p>
&nbsp;

<figure id="attachment_1465" aria-describedby="caption-attachment-1465" style="width: 605px" class="wp-caption aligncenter"><img class="wp-image-1465 " src="/wp-content/uploads/2021/12/info-object-2.png" alt="Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1" width="605" height="265"><figcaption id="caption-attachment-1465" class="wp-caption-text">Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1</figcaption></figure>
<h3 class=""><strong>Components Object</strong></h3>
<p class=""><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#componentsObject"><span style="font-weight: 400;">Components Object in OpenAPI 3.1</span></a><span style="font-weight: 400;"> is also a superset of the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#componentsObject"><span style="font-weight: 400;">one in OpenAPI 3.0</span></a><span style="font-weight: 400;">, which contains an additional </span><code>pathItems</code><span style="font-weight: 400;">object. However, there is a major difference between both formats in terms of </span><span style="font-weight: 400;">Schema</span> <span style="font-weight: 400;">Objects</span><span style="font-weight: 400;"> inside </span><code>Schemas</code><span style="font-weight: 400;">, </span><code>Responses</code><span style="font-weight: 400;">, </span><span style="font-weight: 400;"><code>Parameters</code>, </span><span style="font-weight: 400;">and </span><code>RequestBodies</code><span style="font-weight: 400;"> Objects.</span></p>
<p class="mod-reset">&nbsp;</p>
<p class="mod-reset">&nbsp;</p>


<figure id="attachment_1464" aria-describedby="caption-attachment-1464" style="width: 576px" class="wp-caption aligncenter"><img class="wp-image-1464 " src="/wp-content/uploads/2021/12/component-objects.png" alt="Difference between Component Objects of OpenAPI 3.0 and OpenAPI 3.1" width="576" height="345"><figcaption id="caption-attachment-1464" class="wp-caption-text">Difference between Component Objects of OpenAPI 3.0 and OpenAPI 3.1</figcaption></figure>
<h3 class=""><strong>Schema objects</strong></h3>
<p class=""><span style="font-weight: 400;">As described above, the Schema Object in OpenAPI 3.0 is an extended subset of JSON Schema Specification Wright Draft 00 </span><span style="font-weight: 400;">that made it confusing for users as some things could follow JSON schema standards while others had to be done in OpenAPI&#8217;s style.</span><span style="font-weight: 400;"> However, the Schema Object of OpenAPI 3.1 (exported from APIMatic) is a superset of JSON Schema Specification Draft 2020-12.</span></p>
<p class=""><span style="font-weight: 400;">The new JSON Schema Draft 2020-12 has some major changes with respect to the old JSON Schema Draft 00. Thus, APIMatic Transformer converts this Schema Object from old to new JSON Schema Draft while mapping OpenAPI 3.0 to OpenAPI 3.1.</span></p>
<p class=""><span style="font-weight: 400;">Mappings of some widely used components from Json Schema Draft 00 to Draft 2020-12 are explained further:&nbsp;</span></p>

<h4 class=""><strong>Nullable flag</strong></h4>
<span style="font-weight: 400;">If your OpenAPI 3.0 Schema Object contains a </span><span style="font-weight: 400;">nullable</span><span style="font-weight: 400;"> field, it will be mapped to the “</span><span style="font-weight: 400;">null</span><span style="font-weight: 400;">” type in the list of types in OpenAPI 3.1’s Schema Object since the </span><span style="font-weight: 400;">nullable</span><span style="font-weight: 400;"> field is no longer allowed in JSON Schema Draft 2020-12 and must be declared as follows:</span>
<p class=""><strong>OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody: 
  content: 
    text/plain: 
      example: 3
      schema: 
        nullable: true
        type: integer
  required: true</code></pre>
<p class=""><strong>OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        type:
        - integer
        - &#039;null&#039;
        contentEncoding: int32
        contentMediaType: text/plain
      example: 3
  required: true</code></pre>
<h4 class=""><strong>ExclusiveMinimum and ExclusiveMaximum</strong></h4>
<p class=""><span style="font-weight: 400;">In OpenAPI 3.0, </span><code>exclusiveMinimum</code><span style="font-weight: 400;"> and </span><code>exclusiveMaximum</code><span style="font-weight: 400;"> are of </span><code>Boolean</code><span style="font-weight: 400;"> type and are used in conjunction with </span><code>minimum</code><span style="font-weight: 400;"> and </span><code>maximum</code><span style="font-weight: 400;">&nbsp;respectively. However, in OpenAPI 3.1, <code>exclusiveMinimum</code> and <code>exclusiveMaximum</code> are of type </span><span style="font-weight: 400;">Number</span><span style="font-weight: 400;"> and will convey the same meaning as <code>exclusiveMinimum</code> does in conjunction with minimum or <code>exclusiveMaximum</code> with <code>maximum</code> respectively.&nbsp;</span></p>
<p class=""><strong>OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml"> requestBody: 
  content: 
    application/json: 
      schema: 
        exclusiveMaximum: true
        exclusiveMinimum: true
        maximum: 50
        minimum: 1.22
        type: number
      example: 3
  required: true</code></pre>
<p class=""><strong>OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        exclusiveMaximum: 50
        exclusiveMinimum: 1.22
        type: number
        contentEncoding: double
        contentMediaType: text/plain
      example: 3
  required: true</code></pre>
<h4 class=""><strong>Single-valued Enum and Const</strong></h4>
<p class=""><span style="font-weight: 400;">If you have a single-valued enum in your OpenAPI 3.0 file, the APIMatic Transformer maps this to a field called </span><code>const</code><span style="font-weight: 400;"> since in OpenAPI 3.1, you have the </span><span style="font-weight: 400;">const</span><span style="font-weight: 400;"> field to store the value for a single-valued enum.</span></p>
<p class=""><strong>OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody: 
  content: 
    text/plain:
      schema: 
        enum: 
          - 1
        type: integer
      example: 1
  required: true</code></pre>
<p class=""><strong>OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        const: 1
        type: integer
  required: true
</code></pre>
<h3 class=""><strong>File Upload</strong></h3>
<p class=""><span style="font-weight: 400;">In OpenAPI 3.0, you describe a file upload using </span><code>type</code> <span style="font-weight: 400;">set to <code>string</code> and </span><code>format</code> <span style="font-weight: 400;">set to <code>binary</code> or <code>base64</code> depending on how the file contents will be encoded. However, in OpenAPI 3.1, JSON Schema’s keywords </span><code>contentEncoding</code> <span style="font-weight: 400;">and </span><code>contentMediaType</code> <span style="font-weight: 400;">take care of how the contents will be encoded.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Moreover, you don’t even need to use the Schema Object for a binary file in a POST request.</span></p>
<p class=""><strong>Binary File Upload in OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    application/octet-stream:
      schema:
        type: string
        format: binary</code></pre>
<p class=""><strong>Binary File Upload in OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    application/octet-stream: {}
</code></pre>
<p class=""><strong>Upload via Multipart Request in OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody:
content:
  multipart/form-data:
    schema:
      type: object
      properties:
        userId:
          type: integer
        fileName:
          type: string
          format: binary</code></pre>
<p class=""><strong>Upload via Multipart Request in OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    multipart/form-data:
      schema:
        type: object
        properties:
          userId:
            type: integer
          fileName:
            type: string
            contentMediaType: application/octet-stream</code></pre>
<p class=""><strong>Upload Image with base64 encoding in OpenAPI 3.0</strong></p>

<pre><code class="language-yaml">requestBody:
  content:
    image/png:
      schema:
        type: string
        format: base64</code></pre>
<p class=""><strong>Upload Image with base64 encoding in OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    image/png:
      schema:
        type: string
        format: base64</code></pre>
<h3 class=""><strong>Other Components of OpenAPI 3.0</strong></h3>
<span style="font-weight: 400;">All other components of OpenAPI 3.0 are mapped to OpenAPI 3.1 in APIMatic without any change in them.</span>
<h2 class=""><strong>Additional Changes in OpenAPI 3.1</strong></h2>
<p class="">OpenAPI 3.1 also offers additional updates like multiple examples and reference objects:</p>

<h3 class=""><strong>Multiple Examples inside Schema Object</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI 3.0 allows multiple examples alongside Schema Object (i.e. as a sibling to Schema Object) but does not allow multiple examples inside Schema Object. Fortunately, the support for multiple examples inside Schema Object has been added in OpenAPI 3.1. But the structure of these multiple examples would be different from what we use for the examples alongside the Schema Object.</span></p>
<p class=""><span style="font-weight: 400;">Multiple examples can be defined as a list of examples as shown below, it is recommended to use examples rather than a single example in Schema Object for OpenAPI 3.1.</span></p>
<p class=""><strong>Example inside Schema Object for OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        type: integer
        example: 2</code></pre>
<p class=""><strong>Multiple Examples inside Schema Object for OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        type: integer
        examples:
        - 1
        - 2
        - 3</code></pre>
<h3 class=""><strong>Reference Object</strong></h3>
<p class=""><span style="font-weight: 400;">In OpenAPI 3.1, <code>summary</code> and <code>description</code> keywords have been introduced in </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#reference-object"><span style="font-weight: 400;">Reference Object</span></a><span style="font-weight: 400;">. These <code>summary</code> and <code>description</code> fields by default should override the <code>summary</code> and <code>description</code> fields of the referenced component respectively and if the referenced component does not allow summary or description, the corresponding field will have no effect.</span></p>
<p class=""><span style="font-weight: 400;">For additional changes in OpenAPI 3.1, you can visit the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-specification"><span style="font-weight: 400;">official OpenAPI 3.1 specification</span></a><span style="font-weight: 400;">.</span></p>

<h2 class=""><strong>Transforming OpenAPI 3.0 Files to OpenAPI 3.1 via APIMatic</strong></h2>
<p class=""><span style="font-weight: 400;">APIMatic takes care of all of these mappings behind the scenes. To actually transform a file to OpenAPI 3.1, is just a matter of a few steps. We will be using a sample Customer API</span><span style="font-weight: 400;">&nbsp;in <a href="https://github.com/aliraza1231/files/blob/main/CustomerAPI.yaml">OpenAPI 3.0</a> format for this example.</span></p>

<ol class="">
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Go to the </span><a href="https://www.apimatic.io/dashboard"><span style="font-weight: 400;">APIMatic Dashboard</span></a> <span style="font-weight: 400;">and click on </span><b>Transform API</b><span style="font-weight: 400;">.</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Import the OpenAPI 3.0 specification linked above.</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Select the export format as </span><b>OpenAPI 3.1</b><span style="font-weight: 400;">.</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Click on </span><b>Convert.</b></li>
</ol>
<figure id="attachment_1477" aria-describedby="caption-attachment-1477" style="width: 1920px" class="wp-caption aligncenter"><img class="size-full wp-image-1477" src="/wp-content/uploads/2021/12/apimatic-transformer-openapi3-1.gif" alt="Transforming a OpenAPI 3.0 file to OpenAPI 3.1 in APIMatic" width="1920" height="1080"><figcaption id="caption-attachment-1477" class="wp-caption-text">Transforming a OpenAPI 3.0 file to OpenAPI 3.1 in APIMatic</figcaption></figure>
<p class=""><span style="font-weight: 400;">Yay! Great, you have successfully transformed an OpenAPI 3.0 file to the latest OpenAPI 3.1 format. You can look at the </span><a href="https://github.com/aliraza1231/files/blob/main/CustomerAPI31.yaml"><span style="font-weight: 400;">exported OpenAPI v3.1 specification here</span></a><span style="font-weight: 400;">.</span></p>

<h2 class=""><strong>To Summarize</strong></h2>
<p class=""><span style="font-weight: 400;">The features and improvements offered in OpenAPI 3.1 can open many avenues for API developers in the future as more products and services will move to support OAS 3.1. APIMatic offers a quick solution with </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">API Transformer</span></a> <span style="font-weight: 400;">to convert any API definition into OpenAPI 3.1 format within seconds so you can fully utilize all tools supporting this format, and eliminate the time spent on rewriting API definitions in new formats.</span></p>

</div>
</div>
</div>
</div>						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2021/09/introducing-openapi-3-1-support-in-apimatic/">OpenAPI 3.1 &#8211; What&#8217;s New, and How to Migrate to/from Other API Specs?</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Using Optional and Nullable Properties in API Requests</title>
		<link>/blog/2021/09/using-optional-and-nullable-properties-in-api-requests/</link>
		
		<dc:creator><![CDATA[Maryam Adnan]]></dc:creator>
		<pubDate>Thu, 16 Sep 2021 09:00:51 +0000</pubDate>
				<category><![CDATA[API Documentation]]></category>
		<category><![CDATA[APIMATIC]]></category>
		<category><![CDATA[CodeGen]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SDK]]></category>
		<category><![CDATA[Apimatic]]></category>
		<category><![CDATA[nullable]]></category>
		<category><![CDATA[OpenApi]]></category>
		<category><![CDATA[optional]]></category>
		<category><![CDATA[optional/nullable]]></category>
		<category><![CDATA[Sdks]]></category>
		<guid isPermaLink="false">https://apimatic.io/blog/?p=1436</guid>

					<description><![CDATA[<p>An essential part of an API endpoint is its parameters. While certain parameters must be included in each request, there may be some parameters that may or not may not be included in the request. The optional property was introduced to create unique combinations of such parameters in API requests. In other cases, some parameters [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2021/09/using-optional-and-nullable-properties-in-api-requests/">Using Optional and Nullable Properties in API Requests</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1436" class="elementor elementor-1436">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-4ea2926a elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="4ea2926a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1c6630db" data-id="1c6630db" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-274d9c90 elementor-widget elementor-widget-text-editor" data-id="274d9c90" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class=""><img class="aligncenter wp-image-1451" src="/wp-content/uploads/2021/12/Using-OptionalNullable-Properties-in-API-Requests_Blog_Facebook-1-e1631787822746-1024x436.png" alt="Using Optional and Nullable Properties in API Requests | APIMatic Blog" width="623" height="265" /></p>
<p class=""><span style="font-weight: 400;">An essential part of an API endpoint is its parameters. While certain parameters must be included in each request, there may be some parameters that may or not may not be included in the request. The </span><span style="font-weight: 400;"><code>optional</code> </span><span style="font-weight: 400;">property was introduced to create unique combinations of such parameters in API requests. In other cases, some parameters may be allowed to hold a null value, which is catered via <code>nullable</code> properties that help in coping with the errors if null is not handled correctly. </span></p>
<p class=""><span style="font-weight: 400;">While all endpoint parameter types (query, body, form, and path) can have optional nullable properties, we’ll be focusing on the optional nullable properties of a model’s fields being passed as request parameters in a </span><b>client SDK</b><span style="font-weight: 400;">. </span></p>
<p class=""><i><span style="font-weight: 400;">This blog is the first part of a series on how optional and nullable properties can be used flexibly and in multiple combinations to cater to each parameter of your API requests. </span></i></p>

<h2 class=""><strong>Required, Optional, and Nullable Properties in OpenAPI</strong></h2>
<p class=""><span style="font-weight: 400;">The </span><a href="https://github.com/OAI/OpenAPI-Specification"><span style="font-weight: 400;">OpenAPI Specification</span></a> <span style="font-weight: 400;">is a simple yet powerful way of describing RESTful APIs, in a machine and human-readable format, using JSON or YAML.</span><span style="font-weight: 400;"> OpenAPI has some examples of Uber’s API listed down </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/examples/v2.0/json/uber.json"><span style="font-weight: 400;">in their repository</span></a> <span style="font-weight: 400;">to help understand how the endpoint is specified with OpenAPI. </span></p>
<p class=""><span style="font-weight: 400;">The OpenAPI specification allows defining parameters for an operation or path. Parameters can be of different types i.e header, query, cookies, path parameters.</span></p>

<h3 class=""><b>Required Parameters</b></h3>
<p class=""><span style="font-weight: 400;">One of the attributes that can be defined for these parameters is</span><b> “required”</b><span style="font-weight: 400;"> which simply means whether it is a </span><i><span style="font-weight: 400;">required </span></i><span style="font-weight: 400;">parameter or an </span><i><span style="font-weight: 400;">optional </span></i><span style="font-weight: 400;">one. Let&#8217;s take a look at an example of Uber’s </span><a href="https://developer.uber.com/docs/riders/references/api/v1.2/products-get"><span style="font-weight: 400;">Get Products</span></a><span style="font-weight: 400;"> endpoint specification:</span></p>

<pre class=""><code class="language-json">"paths": {
	"/products": {
  	"get": {
        ...
        "parameters": [
            {
                "name": "latitude",
                "in": "query",
                "description": "Latitude component of location.",
                "required": true,
                "style": "form",
                ...
            },
            {
                "name": "longitude",
                "in": "query",
                "description": "Longitude component of location.",
                "required": true,
                "style": "form",
                ...
            }
    	]
  	    }
      }
  }</code></pre>
<p class=""><span style="font-weight: 400;">You can get more details </span><span style="font-weight: 400;">regarding </span><a href="https://swagger.io/docs/specification/describing-parameters/"><span style="font-weight: 400;">Required and Optional Parameters</span></a> <span style="font-weight: 400;">in the official OAS document.</span></p>

<h3 class=""><b>Nullable Parameters</b></h3>
<p class=""><span style="font-weight: 400;">OpenAPI supports values of data types to be null. To specify, one can use the </span><b>“</b><span style="font-weight: 400;">nullable: true</span><b>” </b><span style="font-weight: 400;">property while defining a data type in OAS version 3.0.0. Let&#8217;s look at the definition of the </span><code>Profile</code> <span style="font-weight: 400;">schema that is defined for the response that we receive for the endpoint </span><a href="https://developer.uber.com/docs/riders/references/api/v1.2/me-get#resource"><span style="font-weight: 400;">User Profile</span></a>. <span style="font-weight: 400;">The attribute </span><code>promo_code</code><span style="font-weight: 400;"> is nullable here:</span></p>

<pre class=""><code class="language-json">"Profile": {
	"title": "Profile",
	"required": [
  	"middle_name",
  	"rider-id"
	],
	"type": "object",
	"properties": {
        "first_name": {
            "type": "string",
            "description": "First name of the Uber user."
        },
        ...
        "promo_code": {
            "type": "string",
            "nullable": "true",
            "description": "Promo code of the Uber user."
        }
    }
}</code></pre>
<p class=""><span style="font-weight: 400;">For more detail, please refer to the </span><a href="https://swagger.io/docs/specification/data-models/data-types/"><span style="font-weight: 400;">Null Property</span></a> <span style="font-weight: 400;">section in the OAS document.</span></p>

<h2 class=""><strong>Optional and Nullable Properties in APIMatic&#8217;s Client SDKs</strong></h2>
<p class=""><span style="font-weight: 400;"><a href="https://apimatic.io/">APIMatic</a> is a developer experience platform that focuses on increasing your API’s adoption with comprehensive documentation, multi-language SDKs, and much more. The SDKs are autogenerated for your API and contain support for optional and nullable properties, that are translated from your OpenAPI specification file. </span></p>
<p class=""><span style="font-weight: 400;">The client SDK is built up of a multitude of endpoints sending data from client to server with the help of parameters. Those parameters can be sent in different parts of a request and hence they are distinguished on the location in which they are sent. Endpoint parameters can be of four types:</span></p>

<ol class="">
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Query parameters</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Path parameters </span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Body parameters</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Form parameters</span></li>
</ol>
<p class=""><span style="font-weight: 400;">These parameters can have multiple properties associated with them like their schema, description, summary, and more. </span><b>Required </b><span style="font-weight: 400;">and </span><b>nullable </b><span style="font-weight: 400;">are two of those properties that can be set for these parameters. </span></p>
<p class=""><span style="font-weight: 400;">During client and server communication, data is serialized from object to JSON string and gets deserialized from JSON string to an object. The data being passed in the parameters can be a simple field, or a model containing multiple fields. Model fields can have </span><em>required</em> <span style="font-weight: 400;">and </span><em>nullable</em> <span style="font-weight: 400;">properties in the same way as a request parameter itself. Regardless of the type of data being passed, </span><em>optional</em> <span style="font-weight: 400;">and </span><em>nullable</em> <span style="font-weight: 400;">is in context to the representation of that data in JSON string during serialization.</span></p>
<p class=""><span style="font-weight: 400;">An</span><strong> o</strong><span style="font-weight: 400;"><strong>ptional</strong> </span><span style="font-weight: 400;">property means that it may or may not be present in the resultant JSON string, while a </span><span style="font-weight: 400;"><strong>required</strong> </span><span style="font-weight: 400;">property means that it will always be present in the JSON string. </span><span style="font-weight: 400;"><strong>Nullable</strong> </span><span style="font-weight: 400;">means that if the property is present in JSON, it can hold a null value, and </span><strong>non-nullable</strong><span style="font-weight: 400;"> means that the value of that property cannot be null in the JSON string. Therefore, we can formulate a total of four combinations for this:</span></p>

<h3><b>1. Optional Nullable</b></h3>
<p class=""><span style="font-weight: 400;">If a field (whether it is a parameter or a part of a model) is uninitialized, i.e., not specified, then </span><span style="font-weight: 400;">it should be ignored in the JSON string during serialization. If it is initialized and assigned a null value explicitly, then it should be represented in the JSON string. </span></p>
<p class=""><span style="font-weight: 400;">Let&#8217;s consider the example of a model/definition </span><code>Profile</code><span style="font-weight: 400;"> which consists of the following fields:</span></p>

<pre class=""><code class="language-c">Profile
{
   string picture;
   string first_name;
   string middle_name;
   string last_name;
   string uuid;
   string rider_id;
   string email;
   bool mobile_verified;
   string promo_code;
}</code></pre>
<p class=""><span style="font-weight: 400;">Its OpenAPI specification looks like this:</span></p>

<pre class=""><code class="language-json">"Profile": {
	"title": "Profile",
	"required": ["middle_name", "rider-id"],
	"type": "object",
	"properties": {
  	"first_name": {
    	"type": "string",
    	"description": "First name of the Uber user."
  	},
  	"last_name": {
    	"type": "string",
    	"description": "Last name of the Uber user."
  	},
  	"middle_name": {
    	"type": "string",
    	"nullable": "true",
    	"description": "Last name of the Uber user."
  	},
  	"email": {
    	"type": "string",
    	"description": "Email address of the Uber user"
  	},
        "mobile_verified": {
    	"type": "boolean",
    	"description": "Mobile verification of Uber user"
  	},
  	"rider-id": {
    	"type": "string",
    	"description": "Rider id of the Uber user"
  	},
  	"picture": {
    	"type": "string",
    	"description": "Image URL of the Uber user."
  	},
  	"promo_code": {
    	"type": "string",
    	"nullable": "true",
    	"description": "Promo code of the Uber user."
  	}
    }
}</code></pre>
<p class=""><span style="font-weight: 400;">During the instantiation of <code>Profile</code>, if  </span><code>promo_code</code><b> </b><span style="font-weight: 400;">is initialized with a null value in the client SDK and sent in the request, the resultant JSON string after serialization will hold its null value as its nullable property:</span></p>

<pre class=""><code class="language-json">{
    "picture": "https://d1w2poirtb3as9.cloudfront.net/f3be498cb0bbf570aa3d.jpeg",
    "first_name": "Uber",
    ...
    "mobile_verified": true,
    "promo_code": "null"
}</code></pre>
<p class=""><span style="font-weight: 400;">If </span><code>promo_code</code><b> </b><span style="font-weight: 400;">is uninitialized during the <code>Profile</code> instantiation for the request, the resultant JSON will ignore <code>promo_code</code>, as it was an </span><b>optional </b><span style="font-weight: 400;">field.</span></p>

<pre class=""><code class="language-json">{
    "picture": "https://d1w2poirtb3as9.cloudfront.net/f3be498cb0bbf570aa3d.jpeg",
    "first_name": "Uber",
    ...
    "mobile_verified": true,
}</code></pre>
<p class=""><span style="font-weight: 400;">If  </span><code>promo_code</code><b> </b><span style="font-weight: 400;">is initialized with a proper value during the <code>Profile</code> instantiation for sending it in the request, the resultant JSON will include the field as specified:</span></p>

<pre class=""><code class="language-json">{
    "picture": "https://d1w2poirtb3as9.cloudfront.net/f3be498cb0bbf570aa3d.jpeg",
    "first_name": "Uber",
    ...
    "mobile_verified": true,
    "promo_code": "uberd340ue"
}</code></pre>
<h3><b>2. Optional Non-Nullable</b></h3>
<p class=""><span style="font-weight: 400;">If a field (whether it’s a parameter or a part of the model) is uninitialized, i.e., not specified, then </span><span style="font-weight: 400;">it should be ignored in JSON string during serialization but as it can not be initialized with a null value, hence we should ignore it JSON. Let’s look at the </span><code>Profile</code> <span style="font-weight: 400;">JSON schema again, where the attribute </span><code>picture</code><b> </b><span style="font-weight: 400;">is optional non-nullable as specified in the OAS of Profile. </span></p>
<p class=""><span style="font-weight: 400;">If </span><code>picture</code><span style="font-weight: 400;"> is initialized with a non-null value when sending it in a request, the resultant JSON string will look like this:</span></p>

<pre class=""><code class="language-json">{
    "picture": "https://d1w2poirtb3as9.cloudfront.net/f3be498cb0bbf570aa3d.jpeg",
    "first_name": "Uber",
    "middle_name": "null",
    "last_name": "Developer",
    "uuid": "f4a416e3-6016-4623-8ec9-d5ee105a6e27",
     ...
}</code></pre>
<p class=""><span style="font-weight: 400;">If </span><b><code>picture</code> </b><span style="font-weight: 400;">is initialized with a <strong>null</strong> value, it can be ignored in the resultant JSON as it is an optional attribute.</span></p>

<pre class=""><code class="language-json">{
    "first_name": "Uber",
    "middle_name": "null",
    "last_name": "Developer",
    "uuid": "f4a416e3-6016-4623-8ec9-d5ee105a6e27",
     ...
}</code></pre>
<h3 class=""><b>3. Required Nullable</b></h3>
<p class=""><span style="font-weight: 400;">Required Nullable attributes will always become part of the resultant JSON string as they are required. It will always be included in the JSON, whether it has a null or non-null value. </span><span style="font-weight: 400;">Let&#8217;s consider the </span><code>middle_name</code><b> </b><span style="font-weight: 400;">as a </span><strong>required nullable </strong><span style="font-weight: 400;">attribute.</span></p>
<p class=""><span style="font-weight: 400;">If </span><code>middle_name</code><b> </b><span style="font-weight: 400;">is initialized with a null value or uninitialized in the request, its JSON output will be:</span></p>

<pre class=""><code class="language-">{
   ...
    "middle_name": "Software",
    "last_name": "Developer",
    "uuid": "f4a416e3-6016-4623-8ec9-d5ee105a6e27",
   ...
}</code></pre>
<p class=""><span style="font-weight: 400;">If </span><code>middle_name</code><b> </b><span style="font-weight: 400;">is initialized with a proper value, the resultant JSON will be:</span></p>

<pre class=""><code class="language-json">{
    ...
    "middle_name": "faloola",
    "last_name": "Developer",
    "uuid": "f4a416e3-6016-4623-8ec9-d5ee105a6e27",
    ...
}</code></pre>
<h3><b>4. Required Non-Nullable</b></h3>
<p class=""><span style="font-weight: 400;">Required Non-Nullable attributes are also a </span><b>must </b><span style="font-weight: 400;">in JSON string during serialization. A null value is not allowed to be specified as <em>required</em> so it cannot be ignored. </span></p>
<p class=""><span style="font-weight: 400;">The </span><code>rider_id</code><b> </b><span style="font-weight: 400;">is a non-nullable attribute in the </span><span style="font-weight: 400;">Profile </span><span style="font-weight: 400;">schema. The null value cannot be specified in this case, and with a non-null value its resultant JSON will be:</span></p>

<pre class=""><code class="language-json">{
    "picture": "https://d1w2poirtb3as9.cloudfront.net/f3be498cb0bbf570aa3d.jpeg",
    "first_name": "Uber",
    "middle_name": "null",
    "last_name": "Developer",
    "uuid": "f4a416e3-6016-4623-8ec9-d5ee105a6e27",
    "rider_id": "8OlTlUG1TyeAQf1JiBZZdkKxuSSOUwu2IkO0Hf9d2HV52Pm25A0NvsbmbnZr85tLVi-s8CckpBK8Eq0Nke4X-no3AcSHfeVh6J5O6LiQt5LsBZDSi4qyVUdSLeYDnTtirw==",
    "email": "uberdevelopers@gmail.com",
    "mobile_verified": true,
    "promo_code": "uberd340ue"
}</code></pre>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">

<hr />

</div>
</div>
<h2 class=""><strong>Conclusion</strong></h2>
<p class=""><span style="font-weight: 400;">It is entirely up to you how you incorporate the optional and nullable properties in your API calls. It is essential to handle null reference exceptions being thrown to the end-user, to avoid any unpleasant experience with your API. Learn more about what APIMatic offers for a comprehensive <a href="https://www.apimatic.io/features/">developer experience</a> and how you can generate feature-packed <a href="https://www.apimatic.io/account/register">SDKs with your API</a> in just a few clicks. Stay tuned for more blogs that go into detail on how optional and nullable properties can be implemented in Java, C#, Python, Ruby, PHP, and TypeScript.</span></p>

</div>
</div>
</div>
</div>						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2021/09/using-optional-and-nullable-properties-in-api-requests/">Using Optional and Nullable Properties in API Requests</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>API Transformer Recipes: Opening ways into IBM API Connect</title>
		<link>/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Tue, 29 Jan 2019 10:53:46 +0000</pubDate>
				<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[API Connect]]></category>
		<category><![CDATA[API Management]]></category>
		<category><![CDATA[IBM]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=686</guid>

					<description><![CDATA[<p>This blog is the third part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate API Transformer into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect/">API Transformer Recipes: Opening ways into IBM API Connect</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="686" class="elementor elementor-686">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-35b2d7dd elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="35b2d7dd" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-7af68430" data-id="7af68430" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-31a86569 elementor-widget elementor-widget-text-editor" data-id="31a86569" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="alignnone wp-image-687 aligncenter" src="/wp-content/uploads/2021/12/1_qEvOmrIaB196xVf5nqTB3Q.jpg" alt="API Transformer Recipes for Opening ways into IBM API Connect" width="800" height="350" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="aed0" class=""><em>This blog is the third part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate </em><a href="/transformer"><em>API Transformer</em></a><em> into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being restricted to a particular set of tools just because they use a certain API specification format. </em></p>
<p id="d964" class="">So your organization decided to use <a href="https://www.ibm.com/cloud/api-connect">IBM API Connect</a> as their API Management platform. You realize it accepts only OpenAPI or WSDL files while you’ve already spent a long time designing the APIs in API Blueprint (or RAML or any other format for that matter). What can you do? This blog provides a step-by-step guide for importing API description files into IBM API Connect without being limited to only OpenAPI or WSDL files.</p>
<h2 id="bea9" class="">What is IBM API Connect?</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="wp-image-688" src="/wp-content/uploads/2021/12/1_DOr2icVAX2_3OEpK6AGfcg.png" alt="" /></p>
</figure>
</div>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="0a03" class="">In case you have never heard of  IBM API Connect , it is essentially an API management platform providing great many tools for managing complete API lifecycles. It allows you to create, test, share, monitor and secure your APIs all in one place.</p>
<h2 id="b0e1" class="">Importing an API into IBM API Connect</h2>
<h3 id="160a" class="">Prerequisites</h3>
<ol class="">
<li>You must have an account on <a href="https://www.ibm.com/cloud/">IBM Cloud</a>.</li>
<li>API Connect service instance must be up and running. If you are new to API Connect, you can create an instance <a href="https://cloud.ibm.com/catalog/services/api-connect">here</a> after providing required details like service name, region, organization, etc.</li>
</ol>
<h3 id="3c78" class=""><strong>Step 1: Open API Connect Dashboard</strong></h3>
<ol class="">
<li>Login to API Connect <a href="https://console.bluemix.net/apis">here</a> using your IBM Cloud account.</li>
<li>From the side bar, navigate to “Existing services” under the API Connect section of the Overview page.</li>
</ol>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:heading /--><!-- wp:heading /--><!-- wp:list /--><!-- wp:heading /--><!-- wp:list /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-689" src="/wp-content/uploads/2021/12/1_QfXYdNiGdSb-YjdudQPvBQ-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="529f" class="">3. Your service instance would be listed here. In case you are unable to view it, ensure that the correct region, organization etc. is selected based on what values you provided at the time of creating the instance. Double click on the instance name and you will be taken to your Dashboard.</p>
<h3 id="4d03">Step 2: Navigate to the APIs Section</h3>
<p id="f32d" class="">The Dashboard is where you manage APIs. The main page will show you a list of catalogs (a “Sandbox” catalog by default) that helps separate Products and APIs for testing.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-690" src="/wp-content/uploads/2021/12/1_TnS0E9moywYXoAO9CRXz5A-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="aa9a">To add new or manage existing APIs, navigate to the “APIs” section as follows:</p>
<ol>
<li>Open the side navigation bar and click on “Drafts” to open the Drafts section.</li>
</ol>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:list /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-691" src="/wp-content/uploads/2021/12/1_zXQ3rTqc8bSYEKKrKHE48A-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>2. Open the “APIs” tab.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-693" src="/wp-content/uploads/2021/12/1_YmCQGaWOhfOj8oUmiFi7Tg-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h3 id="b01e">Step 3: Obtain IBM Compatible API Specification Using API Transformer</h3>
<p id="552b" class="">IBM platform supports only two API description formats: OpenAPI (<code>v2.0, v3.0</code>) and WSDL (for SOAP based services). So to import your API into IBM you will first need to convert your existing API specification into one of these formats. For this, you can use  API Transformer  as described below:</p>
<ol class="">
<li>Navigate to <a href="/transformer"> API Transformer</a>. Sign up if you haven’t already.</li>
</ol>
<p id="b79c" class="">2. Once you are logged in, upload your API description file or provide its URL in the “Convert Now” section. The file that you provide must be in one of the supported formats listed <a href="/transformer">here</a>. All popular format choices like API Blueprint, RAML, WADL, etc. are supported.</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading --><!-- wp:paragraph /--><!-- wp:list /--><!-- wp:paragraph /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-694" src="/wp-content/uploads/2021/12/1_SGh94A6asMWkAGUuBmGupQ-1024x603.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="17f9">3. Choose a target description format based on your needs. Select “Web Service Definition Language (WSDL) — W3C” if you are aiming to create a SOAP based service. For all other cases, select “OpenAPI” (JSON or YAML). You will notice two versions listed for this format (<code>v2.0</code> or <code>v3.0</code>). Pick any since IBM supports both.</p>
<p id="35ec" class="">4. Click on “Convert Now” and if the transformation succeeds, you will be shortly prompted to download the converted file. Save it locally on your system.</p>
<p id="f7c0" class=""><em>Depending on your needs, you may prefer to perform above steps via the </em><a href="https://apimatic.io/apidocs/apimatic/"><em>API</em></a><em> instead, that allows you to integrate </em><a href="/transformer"><em>API Transformer</em></a><em> easily into your workflow.</em></p>
<h3 id="bfb0">Step 4: Import the API into API Connect</h3>
<p id="770a" class="">Now that you have an IBM compatible API description file, you can proceed to importing your API into the API Connect Dashboard.</p>
<p id="e139" class=""><strong>For an OpenAPI file</strong></p>
<ol>
<li>In the APIs section click on “Add” &gt; “Import API from a file or URL”.</li>
</ol>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:list /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-695" src="/wp-content/uploads/2021/12/1_OrWarORe0w0BTpct2ivPdQ-1024x605.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>2. Upload the converted OpenAPI file obtained from API Transformer and click on “Import”.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-696" src="/wp-content/uploads/2021/12/1_Aq8hvkkTwGWZwM6y8BlPzw-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="0091" class=""><strong>For a WSDL file</strong></p>
<ol>
<li>In the APIs section click on “Add” &gt; “API from a SOAP Service”.</li>
</ol>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:list /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-697" src="/wp-content/uploads/2021/12/1_9Zzd_ulEH_WqltKOBiKgUw-1024x605.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>2. Upload the converted WSDL file obtained from API Transformer and click on “Import”.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-698" src="/wp-content/uploads/2021/12/1_sIfpCYemsU_vnM4x_ijVVA-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>If your file imported successfully, it should now be visible in the APIs list.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-699" src="/wp-content/uploads/2021/12/1_adibtuZzbHYEhFB8V9xORw-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h3 id="716b">Step 5: Finalizing the Imported API</h3>
<p id="92aa" class="">This is an optional step suggesting some tweaks to the imported API to make it more compliant with some of the basic IBM requirements. It will help you avoid any issues that could appear later on while managing/publishing the API.</p>
<p id="512f">Open the imported API by clicking on the API name in the APIs list.</p>
<p id="c1f7" class=""><strong>Use only HTTPS Scheme</strong></p>
<p id="f93a" class="">IBM enforces that APIs use only “https” as the scheme. You will need to enable it if the imported API does not use any scheme by default. And if your API allows for any additional schemes, you will need to disable them all.</p>
<ol>
<li>Ensure the tab open is “Design” and then navigate to the “Schemes” section.</li>
<li>Check “https” and uncheck all other schemes.</li>
</ol>
</div>
</div>
</div>
</div>
<!-- /wp:heading --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:list /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-700" src="/wp-content/uploads/2021/12/1_qKeW5Gze9-SgSavif-7MEw-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="215e">3. Save the changes.</p>
<p id="2a8b"><strong>Add IBM Authentication Headers</strong></p>
<p id="290f">The authentication mechanism used by APIs in the IBM’s platform requires two API keys passed as headers namely <code>X-IBM-Client-Id</code> and <code>X-IBM-Client-Secret</code>. You will need to manually define these to avoid issues.</p>
<ol class="">
<li>Navigate to the “Security Definitions” section in the “Design” tab.</li>
<li>Remove any existing security definitions that may have been added during the import process.</li>
<li>Add two “API Key” parameters with “Parameter name” specified as <code>X-IBM-Client-Id</code> and <code>X-IBM-Client-Secret</code> respectively. Both the parameters should be “Located In” the “Header”.</li>
</ol>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:list /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-701" src="/wp-content/uploads/2021/12/1_hcM8Vek31WXj_7HZszPQPg-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>4. In the “Security” section enable both these API keys.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-702" src="/wp-content/uploads/2021/12/1_3AKGvJs-OtPePLRHLvOCUw-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="a590">5. Save the changes.</p>
<h2 id="a05d">What’s next?</h2>
<p id="3c3d" class="">You are now ready to use your API in IBM API Connect to its full potential. Start by adding your API to a default product and publishing that to a catalog. From here on, you can start testing your API, generate a developer portal or utilize other features based on your needs.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-703" src="/wp-content/uploads/2021/12/1_LdawzDINrKXu6-dsb-ZUIA-1024x604.png" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row" style="padding-top: 14px;">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="2395" class="">Continue reading:</p>
<p id="2629" class="">a) <a href="https://apimatic.io/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users">Part 1 of API Transformer Recipes: Enabling Postman’s Team Sharing Features for OpenAPI Users</a><br />b) <a href="https://apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest">Part 2 of API Transformer Recipes — Facilitating Migration from SOAP to REST</a><br />c) <a href="https://apimatic.io/blog/2019/07/moving-to-graphql-from-soap-or-rest">Part 4 of API Transformer Recipes — Moving to GraphQL from SOAP or REST</a><br />d) <a href="https://apimatic.io/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api">Part 5 of API Transformer Recipes — The Whys and Hows of Exposing a SOAP Service Using Your REST API</a></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect/">API Transformer Recipes: Opening ways into IBM API Connect</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>API Transformer Recipes: Enabling Postman’s Team Sharing Features for OpenAPI Users</title>
		<link>/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Thu, 22 Nov 2018 10:53:46 +0000</pubDate>
				<category><![CDATA[API Documentation]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[Postman]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[OpenApi]]></category>
		<category><![CDATA[Team Collaboration]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=579</guid>

					<description><![CDATA[<p>This blog is first of the many to come as part of my new series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate&#160;API Transformer&#160;into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users/">API Transformer Recipes: Enabling Postman’s Team Sharing Features for OpenAPI Users</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="579" class="elementor elementor-579">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-787f8752 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="787f8752" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-7ae21081" data-id="7ae21081" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-64199452 elementor-widget elementor-widget-text-editor" data-id="64199452" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="alignnone wp-image-580" src="/wp-content/uploads/2021/12/1_2lEC0iYnVTvZGXa7gZ00sg-1024x683.jpg" alt="API Transformer Recipes: Enabling Postman’s Team Sharing Features for OpenAPI Users" width="1024" height="683"></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="81d0" class=""><em>This blog is first of the many to come as part of my new series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate&nbsp;</em><a href="http://apimatic.io/transformer"><em>API Transformer</em></a><em>&nbsp;into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being restricted to a particular set of tools just because they use a certain API specification format.</em></p>
<p id="486c" class="">Are you an <a href="http://swagger.io/specification/">OpenAPI</a> user looking to use&nbsp;<a href="https://www.getpostman.com/">Postman</a>&nbsp;somewhere in your development pipeline but don’t really know how? Well, then, you are in the right place. In this blog, I will show you how being an&nbsp;&nbsp;OpenAPI&nbsp;&nbsp;user (or a Swagger one if you prefer the old name) should not stop you from taking advantage of some of the very powerful team collaboration&nbsp;&nbsp;Postman&nbsp;&nbsp;features.</p>
<h2 id="a655" class="">Postman Team Collaboration Features</h2>
<p id="4438" class="">Postman’s easy-to-use and rich interface attracts a large number of users. If you have a team working on APIs, it offers team workspaces to let your team efficiently and effectively collaborate over those APIs while establishing a single source of truth.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-581 aligncenter" src="/wp-content/uploads/2021/12/1_pnc_7FATLxmRqVEBsBWpLA.png" alt=""></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="3f36" class="">Postman has also exposed their <a href="https://docs.api.getpostman.com/">API</a>&nbsp;using which you and your team members can easily push latest collections/API specifications from within your applications.</p>
<h2 id="afc3" class="">From OpenAPI to Postman</h2>
<p id="51a8" class="">&nbsp;OpenAPI is a preferred choice of majority of the users out there due to its extensive support of a wide range of APIs and a strong community. While there are tools out there that support team collaboration for OpenAPI files e.g.&nbsp;<a href="https://swagger.io/tools/swaggerhub/"> SwaggerHub</a>, it may be that you are on the lookout for alternatives. The reasons to that are purely dependant on personal preferences, the type of project you are working on or the size of your team. So if you maintain your specs in&nbsp;&nbsp;OpenAPI but are looking to use&nbsp; Postman, simply including <a href="http://apimatic.io/transformer">API Transformer</a>&nbsp;in your workflow will help achieve your goal.</p>
<p id="e358" class="">One of our customers Phil Sturgeon, who works at <a href="https://www.wework.com/">WeWork</a>, maintains specs in OpenAPI&nbsp;&nbsp;but uses Postman to share them with his team. To streamline this workflow, he makes use of&nbsp;&nbsp;API Transformer. You can check out his blog <a href="https://engineering.wework.com/our-api-specification-workflow-9337448d6ee6">here</a>&nbsp;to learn more.</p>
<h2 id="1bec" class="">Deep Dive Into the Flow</h2>
<p id="eb32" class=""><em>The steps discussed below demonstrate the use of APIs for converting your files and pushing them to</em>&nbsp;<em>Postman</em><em>. However, if you have quite a few files that needs processing you can opt to use the GUIs instead. It is entirely up to you.</em></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="wp-image-582 aligncenter" src="/wp-content/uploads/2021/12/1_lLs3msYrocpEm3VPWCC9Cw-1024x448.png" alt=""></p>
<figcaption>From OpenAPI to Postman: Complete Workflow</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="d73b" class="">The steps involved for you to convert your OpenAPI files to a Postman compatible format are simply:</p>
<h3 id="6cdb"><strong>Step 1: Collect your OpenAPI files</strong></h3>
<p id="7b42" class="">Collect all OpenAPI files you intend to use in&nbsp;&nbsp;Postman. These can be new or updated versions of the existing ones. Pass them one by one as input to the next step.</p>
<h3 id="2420" class=""><strong>Step 2: Transform each file using API Transformer</strong></h3>
<p id="0ccb" class="">The&nbsp;&nbsp;Postman&nbsp;&nbsp;app and&nbsp;&nbsp;API&nbsp;&nbsp;accepts&nbsp;<a href="https://schema.getpostman.com/">Postman schema files</a> as import formats. To use an&nbsp;&nbsp;OpenAPI&nbsp;&nbsp;file in&nbsp;&nbsp;Postman&nbsp;&nbsp;you would, therefore, need to convert it to an appropriate version of the&nbsp;&nbsp;Postman schema file. This is where&nbsp;&nbsp;API Transformer&nbsp;&nbsp;comes into play which supports both schema versions 1.0 and 2.0 .</p>
<p id="c158" class="">So as part of this step, to convert your file, you will need to use the appropriate API Transformer endpoint from the <a href="https://www.apimatic.io/apidocs/apimatic/">CodeGen and Transformer API</a>. Pass&nbsp;&nbsp;OpenAPI&nbsp;&nbsp;file as input along with Postman chosen as the output format (v1.0 or v2.0). If the file is valid, the&nbsp;&nbsp;API&nbsp;&nbsp;will respond with the Postman file which you can then pass on to the next step.</p>
<h3 id="a26f"><strong>Step 3: Push each Postman Schema File to Postman</strong></h3>
<p id="b813" class="">This step involves the use of Postman API to push each of the transformed files into&nbsp;&nbsp;Postman . Once that is done, Postman will automatically sync this file for all the team members giving them the latest view instantly.</p>
<p id="9318" class="">And that’s about it. It is as simple to enable Postman&#8217;s team sharing features for OpenAPI users.</p>
<p id="939e" class="">Continue reading:<br>a) <a href="https://apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest">Part 2 of API Transformer Recipes — Facilitating Migration from SOAP to REST</a><br>b) <a href="https://apimatic.io/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect">Part 3 of API Transformer Recipes — Opening ways into IBM API Connect</a><br>c) <a href="https://apimatic.io/blog/2019/07/moving-to-graphql-from-soap-or-rest">Part 4 of API Transformer Recipes — Moving to GraphQL from SOAP or REST</a><br>d) <a href="https://apimatic.io/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api">Part 5 of API Transformer Recipes — The Whys and Hows of Exposing a SOAP Service Using Your REST API</a></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users/">API Transformer Recipes: Enabling Postman’s Team Sharing Features for OpenAPI Users</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
