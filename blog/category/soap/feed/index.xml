
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>SOAP Archives - APIMatic</title>
	<atom:link href="/blog/category/soap/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>APIMatic is an API documentation tool that provides a complete set of DX components such as autogenerated SDKs, API portal, API docs, live code samples, and more.</description>
	<lastBuildDate>Sat, 23 Apr 2022 11:52:51 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>

<image>
	<url>/wp-content/uploads/2021/10/cropped-cropped-apimaticio-favicon-1-32x32.png</url>
	<title>SOAP Archives - APIMatic</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Top API Specification Trends: 2019-2022</title>
		<link>/blog/2022/03/top-api-specification-trends-2019-2022/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Tue, 15 Mar 2022 13:00:30 +0000</pubDate>
				<category><![CDATA[API Blueprint]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[Postman]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SOAP]]></category>
		<category><![CDATA[OpenApi]]></category>
		<category><![CDATA[Rest API]]></category>
		<category><![CDATA[Soap]]></category>
		<category><![CDATA[Trends]]></category>
		<guid isPermaLink="false">https://apimatic.io/blog/?p=1775</guid>

					<description><![CDATA[<p>Unsurprisingly, the pandemic-ridden era has fueled the rise of APIs in the world. What is more interesting, however, is that with the rise of APIs, a rise in the number of API specification documents has been observed as well. It leads us to believe that more people are adapting to the design-first approach for building [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2022/03/top-api-specification-trends-2019-2022/">Top API Specification Trends: 2019-2022</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class=""><img class="aligncenter wp-image-1844 " src="/wp-content/uploads/2022/04/Top-API-Specification-Trends-01-1024x498.png" alt="" width="726" height="353"></p>
<p class=""><span style="font-weight: 400;">Unsurprisingly, the pandemic-ridden era has fueled the rise of APIs in the world. What is more interesting, however, is that with the rise of APIs, a rise in the number of API specification documents has been observed as well. It leads us to believe that more people are adapting to the design-first approach for building APIs, resulting in intriguing API specification trends.</span></p>
<p class=""><img class="aligncenter wp-image-1786 " src="/wp-content/uploads/2022/04/Yearly-API-Spec-Rise-1024x606.png" alt="" width="631" height="374"></p>
<p class=""><span style="font-weight: 400;">An API specification document is a machine-readable description of an API or service that describes its endpoints, data models, and other related information. In case you are wondering why you need an API description document in the first place, that is an entirely different topic that I have discussed in the blog </span><a href="https://www.apimatic.io/blog/2017/04/why-your-api-needs-machine-readable-description-832e805f6855/"><span style="font-weight: 400;">Why Your API Needs Machine-Readable Description</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">This blog sheds some light on the top API specification trends observed over the past 3 years. You can expect data around which API specification formats were most popular, ones that seem to be emerging over time, and those that are showing signs of imminent death. The trends are based on data collected from APIs imported or transformed by unique users on APIMatic.</span></p>
<h2 class=""><span style="font-weight: 400;">Postman Collections &#8211; Most Popular Input</span></h2>
<p class=""><span style="font-weight: 400;">In the last 3 years, nearly 30,000 users brought only Postman Collections as input into APIMatic either to transform their API specifications to some other format or to generate SDKs/Developer portals. The second-largest number of input API specifications were mainly OpenAPI files.</span></p>
<p class=""><img class="aligncenter wp-image-1778 " src="/wp-content/uploads/2022/04/Imports-1024x620.png" alt="" width="766" height="464"></p>
<p class=""><span style="font-weight: 400;">Many developers test their APIs on Postman which makes it their first choice to store all API-related information. As a next step, if they want to set up a developer experience (DX) platform for their end-users with API documentation and SDKs, it is easier for them to export their stored API information in the form of Postman Collections and use them to generate the required DX kits. This explains the big number of users bringing in Postman Collections as input into APIMatic as well.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">However, the Postman Collection files are structured around making API calls and lack a proper type system to define data more precisely. This makes it a slightly tricky format to deal with when generating good quality SDKs and language-specific documentation, however, you can tackle those issues by following this detailed blog on </span><a href="https://www.apimatic.io/blog/2021/04/curating-postman-collections-to-generate-quality-api-documentation-sdks/"><span style="font-weight: 400;">How to Generate Quality API Documentation &amp; SDKs from Your Postman Collections</span></a><span style="font-weight: 400;">.</span></p>
<h2 class=""><span style="font-weight: 400;">The Rise and Fall of API Specification Formats&nbsp;</span></h2>
<p class=""><span style="font-weight: 400;">In just 3 years, some popular formats have lost some of their fame while others have risen to take the throne.&nbsp;</span></p>
<p class=""><img class="aligncenter wp-image-1777 " src="/wp-content/uploads/2022/04/Emerging-Formats-2-1024x612.png" alt="" width="731" height="437"></p>
<h3 class=""><strong>Insomnia &#8211; An Emerging Format</strong></h3>
<p class=""><span style="font-weight: 400;">Soon after </span><a href="https://konghq.com/blog/kong-acquires-insomnia/"><span style="font-weight: 400;">Kong acquired Insomnia</span></a><span style="font-weight: 400;"> at the end of 2019, the Insomnia specification imports nearly quadrupled in APIMatic. Being quite a newer format, the imports remained quite low as compared to Postman Collections (it being the closest alternative to Insomnia). However, its usage has been increasing steadily ever since.</span></p>
<p class=""><img class="aligncenter wp-image-1779 " src="/wp-content/uploads/2022/04/Insomnia-Growth-1024x603.png" alt="" width="714" height="421"></p>
<h3 class=""><strong>OpenAPI v3.0 Imports Have (Finally) Overtaken v2.0</strong></h3>
<p class=""><span style="font-weight: 400;">Contrary to the API Specifications statistics of </span><a href="https://www.postman.com/state-of-api/api-technologies/"><span style="font-weight: 400;">Postman 2021 State of the API Report</span></a><span style="font-weight: 400;">, APIMatic saw an increase in the number of imports of the newer OpenAPI version v3.0 as compared to v2.0.</span></p>
<p class=""><img class="aligncenter wp-image-1782 " src="/wp-content/uploads/2022/04/OpenAPI-3-vs-OpenAPI-2-1024x608.png" alt="" width="683" height="405"></p>
<p class=""><span style="font-weight: 400;">As can be seen from the graph above, around the start of 2019, the OpenAPI v3.0 imports were initially less than those of v2.0 (also known as Swagger v2.0). Then, they stayed nearly equal for around four months and eventually rose well above them after August 2019. Meanwhile, the imports of v2.0 slowly declined and are expected to continue their downward trend as more and more people adapt to the newer version.&nbsp;</span></p>
<h3 class=""><strong>OpenAPI v3.1 &#8211; Still in Infancy</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI announced its release of the newer version v3.1 in early February 2021 with APIMatic </span><a href="https://docs.apimatic.io/changelog/support-added-for-openapi31/"><span style="font-weight: 400;">releasing support</span></a><span style="font-weight: 400;"> for it in late September.&nbsp;</span></p>
<p class=""><img class="aligncenter wp-image-1783 " src="/wp-content/uploads/2022/04/OpenAPI-3.1-vs-OpenAPI-3.0-Monthly-1024x609.png" alt="" width="688" height="409"><br />
<span style="font-weight: 400;">As was obvious in the case of OpenAPI v3.0 vs v2.0 adoption rates, it takes time for tools and the end-users to adapt to newer versions of specifications. There are still tools out there that continue supporting v2.0 and have yet to add support for OpenAPI v3.0. Even when tools do eventually start supporting a new version, it takes more time for end-users to migrate their existing specifications to it and even more time until they start utilizing the newer features fully.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Therefore, we expect the OpenAPI v3.1 usage to remain quite low for some time. However, with full support for JSON schema and other shiny features, the adoption will open up interesting new possibilities in the future for tools and platforms alike.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">To learn more about APIMatic’s support for OpenAPI v3.1, check out the blog on </span><a href="https://www.apimatic.io/blog/2021/09/migrating-to-and-from-openapi-3-1/"><span style="font-weight: 400;">OpenAPI 3.1 – What’s New, and How to Migrate to/from Other API Specs?</span></a></p>
<h3 class=""><strong>RAML, API Blueprint, WADL are Fading</strong></h3>
<p class=""><img class="aligncenter wp-image-1776 " src="/wp-content/uploads/2022/04/API-Blueprint-WADL-and-RAML-Declining-Imports-1024x606.png" alt="API Blueprint WADL and RAML Declining Imports" width="721" height="427"></p>
<p><span style="font-weight: 400;">In articles that talk about API specifications for REST APIs, OpenAPI/Swagger is usually mentioned the most. However, often you’ll notice API Blueprint, RAML and WADL listed as alternatives as well. All three have been around for quite some time now:</span></p>
<ul class="">
<li style="font-weight: 400;"><span style="font-weight: 400;">RAML’s latest version (v1.0) was released in 2016. It is the primary format used in the Mulesoft Anypoint platform.&nbsp;</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">API Blueprint is the primary format used in the Apiary platform (acquired by Oracle) and was published around 2013.&nbsp;</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">SoapUI users may be familiar with WADL as well, which is a format as old as 2009.&nbsp;</span></li>
</ul>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">
<hr>
</div>
</div>
<p class=""><strong>RAML or OpenAPI on Anypoint Platform &#8211; Now a Choice</strong></p>
<p class=""><span style="font-weight: 400;">RAML v1.0 offers nearly all of the features offered by OpenAPI v3.0. However, while Mulesoft </span><a href="https://blogs.mulesoft.com/dev-guides/open-api-raml-better-together/"><span style="font-weight: 400;">claims that RAML helps you add modularity</span></a><span style="font-weight: 400;"> to your API specification documents, its prime goal is helping define APIs and not modeling API specifications. Mulesoft, therefore, urges users to make use of both OpenAPI and RAML to achieve their goals.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">The trends of the past 3 years talk a little differently and seem to indicate that RAML is slowly losing popularity. RAML may remain a choice for Anypoint users, especially those managing APIs completely on their platform. However, the number of such users seems to be largely decreasing over time as Anypoint itself started </span><a href="https://docs.mulesoft.com/release-notes/platform/oas3"><span style="font-weight: 400;">offering support for OpenAPI v3.0 in 2021</span></a><span style="font-weight: 400;">, and more API management platforms with support for OpenAPI are emerging as well.&nbsp;</span></p>
<p class=""><strong>API Blueprint &#8211; No Longer Actively Maintained</strong></p>
<p class=""><span style="font-weight: 400;">Thanks to Markdown, API Blueprint provided a way to write an API specification document that is more human-friendly. However, the downside of this is a compromise on its ability to be machine-readable. It also lacks some of the advanced features offered by OpenAPI.</span></p>
<p class=""><span style="font-weight: 400;">Interestingly though, API Blueprint is no longer actively maintained since 2019. This may be attributed to Apiary</span><a href="https://blog.apiary.io/OAS-3"><span style="font-weight: 400;"> announcing </span></a><span style="font-weight: 400;">experimental support for OpenAPI v3.0 in early 2019 and can explain why, since then, we are seeing a downward trend in the usage of API Blueprint.&nbsp;&nbsp;</span></p>
<p><strong>WADL &#8211; Best Suited for XML APIs</strong></p>
<p class=""><span style="font-weight: 400;">WADL is an XML-based format for services that work over HTTP. With an increase in REST APIs, JSON has become the most common data exchange format which is best defined using JSON schemas that RAML and OpenAPI support, whereas WADL offers support for only XML schemas.</span></p>
<p class=""><span style="font-weight: 400;">APIs that exchange XML may still benefit from WADL, though based on the trends the number of such APIs seem to be decreasing over time which likely explains the decline in the usage of WADL as well.</span></p>
<h2 class=""><span style="font-weight: 400;">API Specification Transformation Trends</span></h2>
<p class=""><span style="font-weight: 400;">APIMatic offers </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">API Transformer</span></a><span style="font-weight: 400;"> as a free tool to help you transform from one API specification format to another. We support all popular formats including OpenAPI, Postman Collections, RAML, and more.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">I’ll share some interesting trends observed in the API Transformer usage in the 2019-2022 time period. Previously, we conducted similar insights for API Transformer for the years 2017 and 2018. If you are interested, you can check them out here:</span></p>
<ul class="">
<li style="font-weight: 400;"><a href="https://www.apimatic.io/blog/2019/04/api-transformer-insights-2018/"><span style="font-weight: 400;">API Transformer Insights 2018</span></a><span style="font-weight: 400;">&nbsp;</span></li>
<li style="font-weight: 400;"><a href="https://www.apimatic.io/blog/2018/04/a-year-with-api-transformer/"><span style="font-weight: 400;">API Transformer Insights 2017</span></a></li>
</ul>
<div class="row bg-editor-hr-wrap">
<div class="col-md-12 col-xs-12 col-sm-12">
<hr>
</div>
</div>
<h3 class=""><strong>OpenAPI/Swagger v2.0 &#8211; Most Exported Format</strong></h3>
<p class=""><span style="font-weight: 400;">As discussed earlier, the number of OpenAPI v3.0 imports surpassed OpenAPI v2.0 imports in the past 3 years. However, quite surprisingly, the number of OpenAPI v2.0 exports remained quite high as ever, or perhaps more than before. This at least supported the Postman 2021 State of the API Report and my shock was nearly on the same levels as the </span><a href="https://apihandyman.io/we-need-to-talk-openapi-3-is-4-years-old-but-swagger-2-is-still-predominant/"><span style="font-weight: 400;">API Handyman</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><img class="aligncenter wp-image-1781 " src="/wp-content/uploads/2022/04/Most-Exports-1024x611.png" alt="" width="785" height="468"></p>
<p class=""><span style="font-weight: 400;">If you head over to the </span><a href="https://openapi.tools/"><span style="font-weight: 400;">list of popular OpenAPI tools</span></a><span style="font-weight: 400;">, you’ll notice that almost all tools now support OpenAPI v3.0 and there are a large number of tools that don’t even support OpenAPI v2.0 anymore. So, why are people preferring to convert their API specifications to OpenAPI v2.0? Some people are even downgrading from OpenAPI v3.0 to v2.0 (more on that later).&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">While the exact reason is not entirely clear, the apparent reason revolves around the quality of support for OpenAPI v3.0 in tools. OpenAPI v2.0 has been around for much longer than OpenAPI v3.0 so though tools claim to support OpenAPI v3.0 their support for OpenAPI v2.0 may be much more stable and dependable. It is also possible that people are using legacy tools that still only support OpenAPI v2.0.</span></p>
<h3><strong>Top API Specification Transformation Use-Cases</strong></h3>
<p class=""><span style="font-weight: 400;">Over the past three years, some interesting use-cases surrounding API specification transformations have emerged.</span></p>
<p class=""><img class="aligncenter wp-image-1785 " src="/wp-content/uploads/2022/04/Transformation-Use-Cases-1024x615.png" alt="" width="824" height="495"></p>
<p class=""><strong>Postman to OpenAPI</strong></p>
<p class=""><a href="https://learning.postman.com/docs/integrations/available-integrations/apimatic"><span style="font-weight: 400;">Postman&#8217;s APIMatic integration</span></a><span style="font-weight: 400;"> offers its Pro users the ability to convert Postman Collections to any format of their choice. A large number of transformations from Postman Collections can be attributed to that. Nearly 40% of transformations saw users trying to convert their Postman Collection files to OpenAPI.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">As far as the conversion to OpenAPI is concerned, it opens up a large set of tools for Postman users from where they can generate output varying from simple API documentation to feature-packed API developer experience portals with SDKs, live code samples, etc. In other words, converting to OpenAPI helps them manage their APIs better during the later stages of the API lifecycle (e.g. API consumption).</span></p>
<p><strong>OpenAPI v3 to OpenAPI/Swagger v2</strong></p>
<p class=""><span style="font-weight: 400;">15% of the transformations show that users who are already using the newer OpenAPI v3 versions feel the need to downgrade back to the older versions, particularly to OpenAPI v2.0. The only plausible reason seems to be the lack of proper support for OpenAPI v3.0 in tooling that they are looking to use.</span></p>
<p><strong>SOAP to REST</strong></p>
<p class=""><span style="font-weight: 400;">With more benefits, an increasing number of users are looking to migrate their legacy APIs to REST. While the migration is not a single step process, since every SOAP API is accompanied by a WSDL specification/contract, conversion of WSDL to a REST-supporting format (e.g OpenAPI, RAML, etc.) can serve as a starting point. It can give an idea of what the final API can look like.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">In APIMatic, API Transformer offers the </span><a href="https://www.apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest/"><span style="font-weight: 400;">SOAP to REST conversion</span></a><span style="font-weight: 400;">, to its users. Based on the data collected, 8% of the transformations performed by unique users converted their WSDL files to an API specification that supported only REST APIs (e.g. OpenAPI, RAML, WADL, API Blueprint, etc.) in the past three years.</span></p>
<p><strong>Insomnia to Postman</strong></p>
<p class=""><span style="font-weight: 400;">With the increase in Insomnia specification imports, an increase in the number of transformations from Insomnia to Postman Collections has also been observed, constituting about 4% of the total transformations performed by unique users.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Insomnia is the closest alternative to Postman, offering very similar features. However, Postman has been around for quite some time now and hosts a large user base whereas Insomnia is relatively newer. The need to convert between the two formats likely boils down to varying ease of use of both tools as well as personal preference. If, within a single team of your API program you have members who prefer Postman while others prefer Insomnia, then, to ensure smooth collaboration between these members, conversion between the two formats can present itself as a necessary step.</span></p>
<h2 class=""><span style="font-weight: 400;">Invalid API Specifications</span></h2>
<p class=""><span style="font-weight: 400;">Not all the inputs we receive in APIMatic are valid API specification documents. A small portion of them have a few common mistakes or violate the standards one way or another.</span></p>
<h3 class=""><strong>Comparing Success vs Failure Ratio</strong></h3>
<p class=""><img class="aligncenter wp-image-1784 " src="/wp-content/uploads/2022/04/Success-vs-Failure-Ratio-1024x609.png" alt="" width="811" height="482"></p>
<p class=""><span style="font-weight: 400;">Looking at the API specification trends, it is interesting to note that API specification documents that have some form of manual intervention involved showed a greater tendency to be invalid (e.g. RAML, OpenAPI) as compared to API specification documents that are compiled and generated purely by tools (e.g. Postman Collections, Insomnia).&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Out of the total RAML files received by APIMatic in the last three years, nearly 38% had some form of issue. This is in sharp contrast to Postman Collections where out of the total files we received, only 0.99% were invalid.</span></p>
<h3 class=""><strong>Common Causes of Invalidity</strong></h3>
<p class=""><img class="aligncenter wp-image-1780 " src="/wp-content/uploads/2022/04/Invalidity-1024x611.png" alt="" width="715" height="427"></p>
<p class=""><span style="font-weight: 400;">The causes of invalidity vary greatly depending on the format, however, some of the most common ones are listed below:</span></p>
<ol class="">
<li style="font-weight: 400;"><b>Unresolvable references</b><span style="font-weight: 400;"> are the topmost reason for failures. API specifications have different ways to reference other components within the same file or externally. An unresolvable reference is one where the component being referenced either does not exist or exists with a different name or the path to the component is invalid.</span></li>
<li style="font-weight: 400;"><b>Syntax issues</b><span style="font-weight: 400;"> are the second most common reason for failures. A trailing comma in JSON, bad indentation in YAML, or unclosed tag in XML are all examples of invalid syntax.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Often users have specifications where</span><b> types of components do not match</b><span style="font-weight: 400;"> the expected type set by the standards e.g. RAML v1.0 standard sets the type of property </span><code>scopes</code><span style="font-weight: 400;">&nbsp;as a “list” of strings yet plenty of developers declare it as a simple string.</span></li>
</ol>
<p class="">
<p class=""><span style="font-weight: 400;">If you often run into issues like the above, I recommend going through this series of blogs on how to avoid:</span></p>
<ul class="">
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/03/common-mistakes-developers-make-in-their-openapi-3-files/"><span style="font-weight: 400;">Common mistakes developers make in their OpenAPI v3 files</span></a></li>
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/04/common-mistakes-developers-make-in-their-raml-files/"><span style="font-weight: 400;">Common mistakes developers make in their RAML files</span></a></li>
<li style="font-weight: 400;"><a href="https://apimatic.io/blog/2018/09/common-mistakes-developers-make-in-their-api-blueprint-files/"><span style="font-weight: 400;">Common mistakes developers make in their API Blueprint files</span></a></li>
</ul>
<p class="">
<p class=""><span style="font-weight: 400;">In case that doesn’t help, feel free to try some of our </span><a href="https://docs.apimatic.io/api-transformer/transformer-faqs/#troubleshooting"><span style="font-weight: 400;">troubleshooting tips and FAQs</span></a><span style="font-weight: 400;">.&nbsp;</span></p>
<h2 class=""><span style="font-weight: 400;">Conclusion</span></h2>
<p class=""><span style="font-weight: 400;">Recent API specification trends show a mass convergence of the API community towards accepting OpenAPI as the standard for describing REST API services. Postman is expected to continue complementing OpenAPI with its API testing features though it might face some competition from Insomnia in the longer run.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">While new API technologies are emerging like GraphQL, GRPC, and more, REST remains the most popular, with legacy APIs trying to catch up. These trends are expected to play a key role in the evolution of API specifications in 2022 and beyond.&nbsp;</span></p>
</div>
</div>
</div>
</div>
<p>The post <a rel="nofollow" href="/blog/2022/03/top-api-specification-trends-2019-2022/">Top API Specification Trends: 2019-2022</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>The Whys and Hows of Exposing a SOAP Service Using Your REST API</title>
		<link>/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Mon, 22 Jun 2020 13:12:15 +0000</pubDate>
				<category><![CDATA[API Documentation]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SOAP]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Apimatic]]></category>
		<category><![CDATA[Rest]]></category>
		<category><![CDATA[Soap]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=1183</guid>

					<description><![CDATA[<p>This blog is the fifth part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate&#160;API Transformer&#160;into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it should eliminate any assumptions that they might have about being restricted to [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api/">The Whys and Hows of Exposing a SOAP Service Using Your REST API</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1183" class="elementor elementor-1183">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-29e95da2 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="29e95da2" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-76519aca" data-id="76519aca" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-6585503a elementor-widget elementor-widget-text-editor" data-id="6585503a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
			<style>/*! elementor - v3.6.4 - 13-04-2022 */
.elementor-widget-text-editor.elementor-drop-cap-view-stacked .elementor-drop-cap{background-color:#818a91;color:#fff}.elementor-widget-text-editor.elementor-drop-cap-view-framed .elementor-drop-cap{color:#818a91;border:3px solid;background-color:transparent}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap{margin-top:8px}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap-letter{width:1em;height:1em}.elementor-widget-text-editor .elementor-drop-cap{float:left;text-align:center;line-height:1;font-size:50px}.elementor-widget-text-editor .elementor-drop-cap-letter{display:inline-block}</style>				<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12"><!-- wp:group -->
<div class="wp-block-group">
<div class="wp-block-group__inner-container"><!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column" style="flex-basis: 100%;"><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="aligncenter" src="/wp-content/uploads/2021/12/1_2SKA02w5_032Y4Yg5SEvTw-1024x682.png" alt=""></p>
</figure>
<!-- /wp:image --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:group -->
<div class="wp-block-group">
<div class="wp-block-group__inner-container"><!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column" style="flex-basis: 100%;"><!-- wp:paragraph -->
<p class=""><em>This blog is the fifth part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate&nbsp;</em><a href="https://www.apimatic.io/transformer"><em>API Transformer</em></a><em>&nbsp;into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it should eliminate any assumptions that they might have about being restricted to a particular set of tools just because they use a certain API specification format.</em></p>
<!-- /wp:paragraph --></div>
<!-- /wp:column --></div>
<!-- /wp:columns --></div>
</div>
<!-- /wp:group -->

<!-- wp:group -->
<div class="wp-block-group">
<div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p id="3e6f" class="">You can find numerous debates out there on the topic of “SOAP vs REST” including those that believe&nbsp; REST is the new SOAP.&nbsp;Depending on your service and its target consumers, it might actually be a good idea (albeit rarely) to provide that service in the form of both SOAP and REST APIs. Sounds like an awful load of work? Perhaps not. Let’s dig deeper.</p>
<!-- /wp:paragraph --></div>
</div>
<!-- /wp:group -->

<!-- wp:group -->
<div class="wp-block-group">
<div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p id="3dcb" class="">You can also check out one of my earlier blogs on a similar topic where I shared some tips on<a href="https://apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest">migrating your SOAP APIs to REST</a>.</p>
<!-- /wp:paragraph --></div>
</div>
<!-- /wp:group -->

<!-- wp:paragraph -->
<h2 class=""><strong>Is REST not enough?</strong></h2>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="e560" class="">A lot of businesses today have adapted the RESTful approach for their services as it provides a more flexible, lightweight, and efficient solution as compared to the other available alternatives. While this holds true for most cases, there can be times when you’ll find your clients (especially enterprises) seeking a SOAP service to integrate with. Some of the reasons for that can be:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="">
<li>Being slow adopters, enterprise clients might be reluctant to shift to REST since it is still a relatively newer approach to things and differs greatly from the rigid contract-based approach used by SOAP.</li>
<li>Tools and infrastructure used by enterprise clients may not yet support REST well.</li>
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p id="0855">Keeping this in mind, it may be useful to expose your REST service partially/completely in the form of a SOAP service as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h2 class=""><strong>Real-life Use Cases</strong></h2>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="d89b" class=""><a href="https://www.salesforce.com/in/?ir=1">Salesforce</a>&nbsp;provides some APIs as both SOAP and REST allowing developers to integrate in a way that suits them best e.g. check out their&nbsp;<a href="https://developer.salesforce.com/docs/atlas.en-us.api_tooling.meta/api_tooling/intro_api_tooling.htm">Tooling API</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="7b09" class="">One of our clients at APIMatic,&nbsp;<a href="https://www.cdq.ch/">CDQ AG</a>, is a data centric company. Their RESTful services provide a link between their cloud services and business applications. To facilitate smooth integration for enterprise customers, whose infrastructure does not support REST well, they have exposed the same APIs as SOAP services/WSDL interfaces too. This WSDL serves as a contract for both parties. To keep their REST and SOAP APIs in sync, they have integrated&nbsp;<a href="https://www.apimatic.io/transformer/">API Transformer</a>&nbsp;into their workflow which helps generate a new version of the WSDL for every change in their REST API (more on this later). With the newer WSDL, they update their SOAP service accordingly and in order to access the latest changes their service consumers also eventually update their applications based on this latest WSDL.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h3 class=""><strong>SOAP and WSDL</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="076c" class="">While it is not mandatory for every SOAP service to have a WSDL file associated with it, it is widely used as a contract between the SOAP service provider and its consumer. This file provides a complete definition of how the service works, the various operations involved and other fine grain details of all elements and attributes involved. Many tools exist that lets you generate method stubs in almost any language if you have the WSDL file with you.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h3><strong>From REST to SOAP, Using API Transformer</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="1af0" class="">One of the less obvious but distinctive features of&nbsp;<a href="https://www.apimatic.io/transformer/">API Transformer</a>&nbsp;is its ability to convert REST APIs to SOAP by generating WSDL files from popular formats used to describe REST APIs like OpenAPI/Swagger, RAML, API Blueprint, etc. We’ve seen, on average, over 50 unique transformations (unique per user) to WSDL every month for the past three years since this feature was launched.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure style="width: 700px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2021/12/1__B0qfzhhuvta5UoEBWqIWw.png" alt="API Transformer WSDL Export Trend (Jun 2017 — Jun 2020)" width="700" height="292"><figcaption class="wp-caption-text">API Transformer WSDL Export Trend (Jun 2017 — Jun 2020)</figcaption></figure>
<figcaption></figcaption>
Note, however, that the REST APIs spoken of here include not only APIs that completely follow REST architecture style but also those that follow more of a hybrid approach between REST and RPC style.</figure>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h2><strong>Generating WSDL from REST &#8212; How does this work?</strong></h2>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="7341" class="">I went ahead and created a sample OpenAPI&nbsp;<code>v3.0</code>&nbsp;file which I then converted to WSDL using&nbsp;<a href="https://www.apimatic.io/transformer/">API Transformer</a>. Using these files, I will now show you the inner workings of the conversion below. If you are interested to see the complete files, you can find them<a href="https://github.com/fariadev22/api-transformer-recipes/tree/master/Exposing%20a%20SOAP%20API%20Using%20REST">here</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h3 class=""><strong>1. API Information</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="14f8">During the conversion, details related to the API like its identifying title, description and server URLs are extracted from the OpenAPI file and placed in the relevant service metadata of WSDL.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p class=""><strong><em>OpenAPI:</em></strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<pre class=""><code class="language-json">openapi: 3.0.0
info:
  title: HelloService
  description: Swagger file for generating WSDL
version: &#039;1.0&#039;
servers:
  - url: https://www.example.com/SayHello/</code></pre>
<!-- /wp:paragraph -->

<!-- wp:paragraph --><strong><em>WSDL:</em></strong> <!-- /wp:paragraph -->

<!-- wp:paragraph -->
<pre class=""><code class="language-xml">&lt;service name=&quot;HelloService&quot;&gt;
  &lt;documentation&gt;Swagger file for generating WSDL&lt;/documentation&gt;
  &lt;port name=&quot;default_Port&quot; binding=&quot;wsdl:HelloService_Binding&quot;&gt;
    &lt;soap:address location=&quot;https://www.example.com/SayHello/&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; /&gt;
  &lt;/port&gt;
&lt;/service&gt;</code></pre>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h3 class=""><strong>2. OpenAPI Paths</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p class="">Generally, the relative paths in OpenAPI help identify RESTful resources and associated with each of these paths are the various operations possible on these resources. However, these paths have no significance in SOAP/WSDL because the concept of resources is restricted to RESTful APIs only. Only their associated operations are converted to WSDL operations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h3 class=""><strong>3. OpenAPI Operations vs WSDL Operations</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->WSDL operations are defined in an abstract way inside the port types and their concrete details are provided in the bindings. Information from OpenAPI operations is loaded into both these port types and binding operations. <!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p class=""><em><strong>OpenAPI</strong>:</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<pre class=""><code class="language-json">/message:
   get:
     tags:
      - Messages
     description: View message entry
     operationId: GetMessage
     parameters:
       - name: messageId
         in: query
         required: true
         schema:
           type: string
     responses:
       200:
         description: Message object against the id, if found
         content:
           application/json:
             schema:
               $ref: &#039;#/components/schemas/Message&#039;
       404:
         description: No messages found
         content:
           application/json:
             schema:
               $ref: &#039;#/components/schemas/Error&#039;</code></pre>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="4899" class=""><em><strong>WSDL</strong>:</em></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-xml">&lt;portType name=&quot;HelloService_PortType&quot;&gt;
  &lt;operation name=&quot;GET_GetMessage&quot;&gt;
    &lt;documentation&gt;View message entry&lt;/documentation&gt;
    &lt;input message=&quot;wsdl:GET_GetMessage_InputMessage&quot; /&gt;
    &lt;output message=&quot;wsdl:GET_GetMessage_OutputMessage&quot;&gt;
        &lt;documentation&gt;Message object against the id, if found&lt;/documentation&gt;
    &lt;/output&gt;
    &lt;fault name=&quot;GET_GetMessage_404&quot; message=&quot;wsdl:GET_GetMessage_404&quot;&gt;
        &lt;documentation&gt;No messages found&lt;/documentation&gt;
    &lt;/fault&gt;
    &lt;/operation&gt;
&lt;/portType&gt;
&lt;binding name=&quot;HelloService_Binding&quot; type=&quot;wsdl:HelloService_PortType&quot;&gt;
  &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; /&gt;
  &lt;operation name=&quot;GET_GetMessage&quot;&gt;
    &lt;soap:operation soapAction=&quot;GET_GetMessage&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; /&gt;
    &lt;input&gt;
      &lt;soap:body use=&quot;literal&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; /&gt;
    &lt;/input&gt;
    &lt;output&gt;
      &lt;soap:body use=&quot;literal&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; /&gt;
    &lt;/output&gt;
    &lt;fault name=&quot;GET_GetMessage_404&quot;&gt;
      &lt;soap:fault use=&quot;literal&quot; name=&quot;GET_GetMessage_404&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; /&gt;
    &lt;/fault&gt;
  &lt;/operation&gt;
&lt;/binding&gt;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<h4 id="1625"><strong>HTTP Verb</strong></h4>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="53c0" class="">An OpenAPI operation has a distinct HTTP verb associated with it e.g.&nbsp;<code>GET</code>,&nbsp;<code>POST</code>,&nbsp;<code>DELETE</code>, etc. indicating the type of functionality that is expected to be performed on the resource. All OpenAPI operations are converted to&nbsp;<code>POST</code>&nbsp;methods for SOAP/WSDL conversion.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h4 id="722f" class=""><strong>WSDL Operation Name</strong></h4>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="2f34" class="">The operation name for WSDL is generated by combining the HTTP verb and operation id/name from the OpenAPI operation and serves as a unique identifier.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h4 id="ee27"><strong>Request Parameters</strong></h4>
<!-- /wp:paragraph -->

<!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:image -->
<figure class="wp-block-image size-large is-resized">
<p class="mod-reset"><img class="aligncenter" src="/wp-content/uploads/2021/12/0_WZXzYl_m6KZQWtpE-1.jpg" alt="" width="500" height="505"></p>
<figcaption>Input parameters are wrapped and sent in SOAP body</figcaption>
</figure>
<!-- /wp:image --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:paragraph -->
<p id="4d93">All associated request parameters of an OpenAPI operation are wrapped in a single new input type and sent in the form of an&nbsp;<strong>input message</strong>&nbsp;in the SOAP body. The wrapper input type’s name is generated by combining the original HTTP verb of the operation with the operation’s id and a postfix indicating it as the input type.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="cd0f" class="">Unlike JSON, a root XML element cannot be an array. So even if only a single parameter is involved, a wrapper type helps preserve all type related information of it including array representations that would otherwise be lost.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->In the WSDL example above, note the use of the&nbsp;<code>message</code>&nbsp;attribute in&nbsp;<code class="">&lt;input&gt;</code>&nbsp;that provides a link to the concrete&nbsp;<code>&lt;message&gt;</code>&nbsp;definition in WSDL. <!-- /wp:paragraph --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:paragraph -->
<h4 id="3f92"><strong>Operation Responses</strong></h4>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="7661">The first success response definition (of the range 2XX) is also wrapped in a new output type which defines the body of the&nbsp;<strong>output message</strong>&nbsp;received. The type name is generated in a similar fashion as that of the input type except for the postfix which indicates it as an output type.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="5e1e" class="">Error responses of the range 400 and above are considered SOAP&nbsp;<strong>faults</strong>. Note, however, that response code has no significance in WSDL.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="6fa3">Again, note the use of the&nbsp;<code>message</code>&nbsp;attribute in&nbsp;<code>&lt;output&gt;</code>&nbsp;and&nbsp;<code>&lt;fault&gt;</code>&nbsp;that provides a link to the concrete&nbsp;<code>&lt;message&gt;</code>&nbsp;definition in WSDL.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h4 id="0c7e"><strong>SOAP Binding Transport Protocol</strong></h4>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="739a" class="">SOAP binding transport protocol is assumed to be HTTP for the conversion. Since SOAP supports other transport protocols as well, this can be modified manually if required.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<h3><strong>4. WSDL Messages</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="ae44" class="">WSDL messages defined using the&nbsp;<code>&lt;message&gt;</code>&nbsp;tag help describe the data being exchanged between the service provider and the client. Request messages are associated with the&nbsp;<code>&lt;input&gt;</code>&nbsp;tag while response messages are associated with the&nbsp;<code>&lt;output&gt;</code>&nbsp;or&nbsp;<code>&lt;fault&gt;</code>&nbsp;tag. Different parts of a message define its components and help provide a link to their concrete type schema definitions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="796f" class=""><em><strong>WSDL</strong>:</em></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-xml">&lt;message name=&quot;GET_GetMessage_InputMessage&quot;&gt;
  &lt;part name=&quot;GET_GetMessage_InputMessage&quot; element=&quot;schemas:GET_GetMessage_InputMessage&quot; /&gt;
&lt;/message&gt;
&lt;message name=&quot;GET_GetMessage_OutputMessage&quot;&gt;
  &lt;part name=&quot;GET_GetMessage_OutputMessage&quot; element=&quot;schemas:GET_GetMessage_OutputMessage&quot; /&gt;
&lt;/message&gt;
&lt;message name=&quot;GET_GetMessage_404&quot;&gt;
  &lt;part name=&quot;GET_GetMessage_404&quot; element=&quot;schemas:GET_GetMessage_404&quot; /&gt;
&lt;/message&gt;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<h3><strong>5. OpenAPI Schema and XML Schema</strong></h3>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="5503">Schema definitions from OpenAPI are added to the XML schema(s) in WSDL&nbsp;<code>&lt;types&gt;</code>&nbsp;section. These not only include the types defined globally in OpenAPI&nbsp;<code>schema</code>&nbsp;definitions but also additional types that represent the wrapped request/response messages.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="490a" class="">In OpenAPI, you can fine-tune your schema definitions to represent XML types by adding<a href="https://swagger.io/docs/specification/data-models/representing-xml/">XML metadata</a>&nbsp;like information about namespace, prefix, XML node name, whether the property is an attribute or not, etc. Let’s have a look at how an OpenAPI schema defined with these attributes translates to a type in WSDL during the conversion.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="62f3" class=""><em><strong>OpenAPI</strong>:</em></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">Message:
  title: Message
  required:
    - from
    - to
    - text
    - date
  type: object
  properties:
    from:
      type: string
    to:
      type: string
    text:
      type: string
    date:
      type: string
      format: date-time
    id:
      type: string
      xml:
        name: id
        attribute: true
  xml:
    name: MessageEntry
    namespace: https://www.example.com/message
    prefix: m</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p id="f2c3"><em>WSDL:</em></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-xml">&lt;types&gt;
  &lt;xs:schema xmlns:tns=&quot;https://www.example.com/message&quot; targetNamespace=&quot;https://www.example.com/message&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;
    &lt;xs:complexType name=&quot;MessageEntry&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element minOccurs=&quot;1&quot; name=&quot;from&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element minOccurs=&quot;1&quot; name=&quot;to&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element minOccurs=&quot;1&quot; name=&quot;text&quot; type=&quot;xs:string&quot; /&gt;
        &lt;xs:element minOccurs=&quot;1&quot; name=&quot;date&quot; type=&quot;xs:dateTime&quot; /&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:string&quot; /&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:schema&gt;
&lt;/types&gt;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:list -->
<ul class="">
<li>The XML name&nbsp;<code>MessageEntry</code>&nbsp;specified in the OpenAPI schema overrides the schema’s original name&nbsp;<code>Message</code>&nbsp;and is used instead, when creating the XML schema type in WSDL.</li>
<li>The boolean&nbsp;<code>attribute</code>&nbsp;flag in property&nbsp;<code>id</code>&nbsp;helped create an XML attribute of the same name as can be seen from the above example.</li>
<li>Furthermore, notice how in the example above, the&nbsp;<code>namespace</code>&nbsp;information from the OpenAPI schema helped us place the type definition in&nbsp;<code>&lt;schema&gt;</code>&nbsp;of the same namespace in WSDL. The prefix assigned to this namespace&nbsp;<code>m</code>&nbsp;is also preserved in the root tag of WSDL.</li>
</ul>
<!-- /wp:list -->

<!-- wp:preformatted -->
<pre><code class="language-xml">&lt;definitions 
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
  xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; 
  xmlns:schemas=&quot;https://www.example.com/SayHello/schemas&quot; 
  xmlns:wsdl=&quot;https://www.example.com/SayHello/wsdl&quot; 
  xmlns:m=&quot;https://www.example.com/message&quot; 
  xmlns:e=&quot;https://www.example.com/error&quot; 
  targetNamespace=&quot;https://www.example.com/SayHello/wsdl&quot; xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p id="693a" class="">Let’s now see how XML metadata specified in request/response schema translate to a type in WSDL:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="d63d" class=""><em><strong>OpenAPI</strong>:</em></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">responses:
  200:
    description: List of all message objects
    content:
      application/json:
        schema:
          type: array
          items:
            $ref: &#039;#/components/schemas/Message&#039;
          description: List of all message objects
          xml:
            name: Messages
            wrapped: true</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p id="c37b" class=""><em><strong>WSDL</strong>:</em></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-xml">&lt;types&gt;
  &lt;xs:schema xmlns:tns=&quot;https://www.example.com/SayHello/schemas&quot; targetNamespace=&quot;https://www.example.com/SayHello/schemas&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;  
    &lt;xs:complexType name=&quot;GET_GetMessages_OutputMessage&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name=&quot;Messages&quot;&gt;
          &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
              &lt;xs:element minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot; name=&quot;response&quot; type=&quot;m:MessageEntry&quot;&gt;
                &lt;xs:annotation&gt;
                  &lt;xs:documentation&gt;List of all message objects&lt;/xs:documentation&gt;
                &lt;/xs:annotation&gt;
              &lt;/xs:element&gt;
            &lt;/xs:sequence&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:schema&gt;
&lt;/types&gt;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<h2 id="b148">You have the WSDL — What next?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p id="6f9f" class="">Having a WSDL basically means, you have a skeleton of what your SOAP service will look like. Various tools and frameworks can then help you accelerate actual implementation of the SOAP service by generating stubs. However, before you start implementing, you need to decide whether you plan to keep the SOAP service independent from your existing REST service or not. The former case will have bigger maintenance cost and it will be difficult to keep both services in sync when changes occur. The recommended way is to implement this SOAP service more as a proxy service that handles SOAP payloads but converts them to those compatible with your existing REST service. This way your actual service will still be the REST service while the SOAP service will help facilitate the smaller chunk of your customers like enterprises. What option you pick is something you are the best judge of.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image">
<figure style="width: 700px" class="wp-caption aligncenter"><img src="/wp-content/uploads/2021/12/1_zo53IiiN0ricDCXce6IvNw-2.png" alt="From REST to SOAP, using API Transformer" width="700" height="466"><figcaption class="wp-caption-text">From REST to SOAP, using API Transformer</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:heading -->
<h2 id="0df0" class="">Conclusion</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p id="1aae" class="">REST or SOAP or both? I hope this article offered some clarification in this regard. Ultimately the choice really depends on your service and your target customers. Once you’ve made the decision, there are various tools like&nbsp;<a href="https://www.apimatic.io/transformer/" target="_blank" rel="noreferrer noopener">API Transformer</a>&nbsp;available to help you get started.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p id="4e4f" class="">Continue reading more API Transformer Recipes:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="">
<li><a href="https://apimatic.io/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users" target="_blank" rel="noreferrer noopener">Enabling Postman’s Team Sharing Features for OpenAPI Users</a></li>
<li><a href="https://apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest" target="_blank" rel="noreferrer noopener">Facilitating Migration from SOAP to REST</a></li>
<li><a href="https://apimatic.io/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect" target="_blank" rel="noreferrer noopener">Opening ways into IBM API Connect</a></li>
<li><a href="https://apimatic.io/blog/2019/07/moving-to-graphql-from-soap-or-rest" target="_blank" rel="noreferrer noopener">Moving to GraphQL from SOAP or REST</a></li>
</ul>
<!-- /wp:list --></div>
</div>
<!-- /wp:group --></div>
</div>
</div>
</div>						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api/">The Whys and Hows of Exposing a SOAP Service Using Your REST API</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Moving to GraphQL from SOAP or REST</title>
		<link>/blog/2019/07/moving-to-graphql-from-soap-or-rest/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 12 Jul 2019 11:27:02 +0000</pubDate>
				<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[Blog]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SOAP]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Apimatic]]></category>
		<category><![CDATA[GraphQL]]></category>
		<category><![CDATA[Graphql Schema]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=624</guid>

					<description><![CDATA[<p>This blog is the fourth part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate&#160;API Transformer into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being restricted [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2019/07/moving-to-graphql-from-soap-or-rest/">Moving to GraphQL from SOAP or REST</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="624" class="elementor elementor-624">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-5fc28771 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="5fc28771" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1d7582c7" data-id="1d7582c7" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-4f627216 elementor-widget elementor-widget-text-editor" data-id="4f627216" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-625" src="/wp-content/uploads/2021/12/1_R4yFQi_9PINp_LHuwRsVag-1024x512.jpg" alt=""></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="e10f" class=""><em>This blog is the fourth part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate&nbsp;</em><a href="https://www.apimatic.io/transformer"><em>API Transformer</em></a><em> into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being restricted to a particular set of tools just because they use a certain API specification format.&nbsp;</em></p>
<h2 id="8e77" class="">Announcing support for GraphQL Schema</h2>
<p id="4d39" class="">Oh yes, you heard it right. You can now&nbsp;<a href="https://docs.apimatic.io/changelog/support-for-exporting-graphql-schema-files-now-available/">export GraphQL Schema from APIMatic</a>&nbsp;using&nbsp; API Transformer! Previously, we provided our users means of&nbsp;<a href="https://blog.apimatic.io/api-transformer-recipes-facilitating-migration-from-soap-to-rest-72b8248432d8">migrating from SOAP to REST</a>, and now also aim to facilitate those SOAP/REST users looking to migrate to GraphQL.</p>
<p id="c99b" class="">Why GraphQL, you wonder? Without going into details, GraphQL is known for being simpler, faster and efficient allowing users to fetch exactly the data they need. Many strongly believe that GraphQL is the future of APIs. So if you are one of them and are considering moving to GraphQL, read on.</p>
<p id="2a57" class="">Our support for GraphQL schema is currently in beta so we are open to any feedback/suggestions that you might have.</p>
<h2 id="512e" class="">Role of GraphQL Schema</h2>
<p id="7f3a" class="">GraphQL schemas for a service are defined using&nbsp;<a href="https://graphql.org/learn/schema/">GraphQL SDL</a>&nbsp;(schema definition language) having a pretty simple syntax for defining various components like types, queries, mutations etc. We’ll take a look at some examples later in this blog.</p>
<p id="50c9">A GraphQL schema is at the core of any GraphQL server implementation. It describes the functionality available to the client applications that connect to it. So having this schema file will serve as a key starting point for migrating your API to GraphQL. You can then easily generate server code, resolver signatures, etc. from it using various tools available out there.</p>
<h2 id="109f">Export GraphQL Schema Files with API Transformer</h2>
<p id="d41a" class="">Bring your API files and export them to GraphQL schema using&nbsp;<a href="https://www.apimatic.io/transformer">API Transformer</a>. All major input formats (e.g. OpenAPI, RAML, API Blueprint, etc.) are supported.</p>
<p id="5919">The following features of the schema are supported:</p>
<ul class="">
<li>Object types</li>
<li>Scalar and Enumeration types</li>
<li>Input types</li>
<li>Arguments</li>
<li>Queries</li>
<li>Mutations</li>
<li>Lists and Non-null fields</li>
</ul>
<p id="8a1e" class="">GraphQL itself does not impose any strict naming conventions other than a list of allowed characters mentioned in their&nbsp;<a href="https://graphql.github.io/graphql-spec/June2018/#sec-Names">spec</a>. However, keeping in mind some of the best practices highlighted for&nbsp;<a href="https://graphqlmastery.com/blog/graphql-best-practices-for-graphql-schema-design">GraphQL schema design</a>,&nbsp;<a href="https://blog.apollographql.com/designing-graphql-mutations-e09de826ed97">mutations</a>&nbsp;and&nbsp;<a href="https://graphqlmastery.com/blog/how-to-use-graphql-enum-type-and-its-best-practices">GraphQL enum types</a>, we follow some conventions to make the migration process for our users easier. These conventions aim to facilitate development and interoperability.</p>
<p id="2c5f"><strong>Conventions</strong></p>
<ul class="">
<li>The names of various components will obey the rules specified in the spec.</li>
<li>Object/Input and Enumeration type names will be&nbsp;<code>pascal</code>&nbsp;cased.</li>
<li>All field names will be&nbsp;<code>camel</code>&nbsp;cased.</li>
<li>Enumeration field names will be&nbsp;<code>upper</code>&nbsp;cased to represent their nature as constants.</li>
<li>HTTP verb will be prepended with query/mutation names to represent the action that will be performed upon calling it.</li>
</ul>
<h2 id="2593">For SOAP Users — Migrating to GraphQL</h2>
<p id="04e6" class="">With&nbsp; API Transformer, SOAP users can start migrating to GraphQL by obtaining a GraphQL schema file from their service WSDL file. This involves a conversion of all WSDL types to GraphQL schema types, operations to mutations and attributes to arguments. The example below illustrates this:</p>
<p id="7774" class="">WSDL example:</p>
<pre class=""><code class="language-xml">&lt;definitions name=&quot;HelloService&quot; targetNamespace=&quot;http://www.examples.com/wsdl/HelloService.wsdl&quot; xmlns=&quot;http://schemas.xmlsoap.org/wsdl/&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; xmlns:tns=&quot;http://www.examples.com/wsdl/HelloService.wsdl&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:s=&quot;http://www.examples.com/schema1&quot;&gt;
  &lt;types&gt;
      &lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.examples.com/schema1&quot; elementFormDefault=&quot;qualified&quot;&gt;
        &lt;element name=&quot;GreetingMessage&quot;&gt;
            &lt;complexType&gt;
                &lt;sequence&gt;
                    &lt;element name=&quot;senderName&quot; type=&quot;xsd:string&quot;/&gt;
                    &lt;element name=&quot;greeting&quot; type=&quot;xsd:string&quot;/&gt;
                &lt;/sequence&gt;                
            &lt;/complexType&gt;
        &lt;/element&gt;
      &lt;/schema&gt;
  &lt;/types&gt;
  &lt;message name=&quot;SendMessageRequest&quot;&gt;
      &lt;part name=&quot;message&quot; type=&quot;s:GreetingMessage&quot;/&gt;
  &lt;/message&gt;
  &lt;message name=&quot;SendMessageResponse&quot;&gt;
      &lt;part name=&quot;message&quot; type=&quot;s:GreetingMessage&quot;/&gt;
  &lt;/message&gt;
  &lt;portType name=&quot;Hello_PortType&quot;&gt;
      &lt;operation name=&quot;sendMessage&quot;&gt;
         &lt;input message=&quot;tns:SendMessageRequest&quot;/&gt;
         &lt;output message=&quot;tns:SendMessageResponse&quot;/&gt;
      &lt;/operation&gt;
  &lt;/portType&gt;
  &lt;binding name=&quot;Hello_Binding&quot; type=&quot;tns:Hello_PortType&quot;&gt;
      &lt;soap:binding style=&quot;rpc&quot;
         transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt;
      &lt;operation name=&quot;sendMessage&quot;&gt;
         &lt;soap:operation soapAction=&quot;sendMessage&quot;/&gt;
         &lt;input&gt;
            &lt;soap:body encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;
               namespace=&quot;urn:examples:helloservice&quot;
               use=&quot;encoded&quot;/&gt;
         &lt;/input&gt;    
         &lt;output&gt;
            &lt;soap:body encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;
               namespace=&quot;urn:examples:helloservice&quot;
               use=&quot;encoded&quot;/&gt;
         &lt;/output&gt;
      &lt;/operation&gt;
   &lt;/binding&gt;
   &lt;service name=&quot;Hello_Service&quot;&gt;
      &lt;documentation&gt;WSDL File for HelloService&lt;/documentation&gt;
      &lt;port binding=&quot;tns:Hello_Binding&quot; name=&quot;Hello_Port&quot;&gt;
         &lt;soap:address location=&quot;http://www.examples.com/SayHello/&quot; /&gt;
      &lt;/port&gt;
   &lt;/service&gt;   
&lt;/definitions&gt;</code></pre>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:table -->
<figure class="wp-block-table"></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row" style="padding-top: 0px;">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="d1fc" class="">GraphQL schema obtained by converting above WSDL file using&nbsp; API Transformer:</p>
<pre class=""><code class="language-cs"># API Name: &quot;HelloService&quot;
# Host: http://www.examples.com/SayHello/
# WSDL File for HelloService

type GreetingMessage {
    senderName: String!
    greeting: String!
}

type SendMessageRequest {
    greetingMessage: GreetingMessage!
}

type SendMessageResponse {
    greetingMessage: GreetingMessage!
}

input GreetingMessageInput {
    senderName: String!
    greeting: String!
}

input SendMessageRequestInput {
    greetingMessage: GreetingMessageInput!
}

input CreateSendmessageInput {
    body: SendMessageRequestInput!
}

type Query {
    _: Boolean
}

type Mutation {
    createSendmessage(input: CreateSendmessageInput!): SendMessageResponse!
}

schema {
    mutation: Mutation
    query: Query
}</code></pre>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"></figure>
<!-- /wp:table -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="8674">For REST Users — Layering GraphQL on top</h2>
<p id="91f0" class="">Instead of completely migrating to GraphQL, users generally prefer to add a GraphQL layer on top of REST and enjoy benefits of both. The choice is yours depending on your service and system needs.</p>
<p id="841a" class="">You can convert your RESTful API defined in one of the popular formats like OpenAPI/Swagger, RAML, etc. to GraphQL schema with&nbsp; API Transformer. The conversion process will:</p>
<ul class="">
<li>Convert GET operations to GraphQL queries while other operations involving server-side changes to GraphQL mutations.</li>
<li>Convert complex types in the API to GraphQL object and enumeration types.</li>
<li>Wrap operation parameters in a GraphQL input type and link that input type to respective query/mutation arguments.</li>
</ul>
<p id="fce7">The example below shows the conversion:</p>
<p id="1f1d" class="">OpenAPI 3.0 example:</p>
<pre class=""><code class="language-yaml">openapi: 3.0.0
info:
  title: Calculator
  description: Simple Calculator API
  version: &#039;1.0&#039;
servers:
- url: https://examples.devapi.dream.press/apps/calculator  
paths:
  /{operation}:
    get:
      description: Calculates the expression based on the x and y operator
      operationId: Calculate
      parameters:
      - name: operation
        in: path
        required: true
        schema:
          $ref: &#039;#/components/schemas/OperationType&#039;
      - name: x
        in: query
        required: true
        schema:
          type: number
          format: double
      - name: y
        in: query
        required: true
        schema:
          type: number
          format: double
      responses:
        200:
          description: &#039;Returns the result of operation&#039;
          content:
            text/plain:
              schema:
                type: number
                format: double      
components:
  schemas:
    OperationType:
      enum:
      - SUM
      - SUBTRACT
      - MULTIPLY
      - DIVIDE
      type: string
      description: Possible operations are sum, subtract, multiply, divide</code></pre>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:table -->
<figure class="wp-block-table"></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="2920" class="">GraphQL schema obtained by converting above OpenAPI 3.0 file using&nbsp; API Transformer:</p>
<pre class=""><code class="language-cs"># API Name: &quot;Calculator&quot;
# Host: https://examples.devapi.dream.press/apps/calculator
# Simple Calculator API

&quot;Possible operations are sum, subtract, multiply, divide&quot;
enum OperationType {
    DIVIDE
    MULTIPLY
    SUBTRACT
    SUM
}

input GetCalculateInput {
    operation: OperationType!
    x: Float!
    y: Float!
}

type Query {
    &quot;Calculates the expression based on the x and y operator&quot;
    getCalculate(input: GetCalculateInput!): Float!
}

type Mutation {
    _: Boolean
}

schema {
    mutation: Mutation
    query: Query
}</code></pre>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"></figure>
<!-- /wp:table -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="5c1b">Conclusion</h2>
<p id="0841" class="">We hope you found our migration guide to GraphQL useful. If you have any feedback for our GraphQL schema export feature, feel free to reach out.</p>
<p id="28a8" class="">Continue reading more API Transformer Recipes:</p>
<ul class="">
<li><a href="https://apimatic.io/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users" target="_blank" rel="noreferrer noopener">Enabling Postman’s Team Sharing Features for OpenAPI Users</a></li>
<li><a href="https://apimatic.io/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest" target="_blank" rel="noreferrer noopener">Facilitating Migration from SOAP to REST</a></li>
<li><a href="https://apimatic.io/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect" target="_blank" rel="noreferrer noopener">Opening ways into IBM API Connect</a></li>
<li><a href="https://apimatic.io/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api">The Whys and Hows of Exposing a SOAP Service Using Your REST API</a></li>
</ul>
<p class="">Thanks to&amp;nbsp;Adeel Ali.</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2019/07/moving-to-graphql-from-soap-or-rest/">Moving to GraphQL from SOAP or REST</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>API Transformer Recipes — Facilitating Migration from SOAP to REST</title>
		<link>/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Thu, 20 Dec 2018 08:17:22 +0000</pubDate>
				<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[REST APIs]]></category>
		<category><![CDATA[SOAP]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Rest]]></category>
		<category><![CDATA[Soap]]></category>
		<category><![CDATA[Wsdl]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=564</guid>

					<description><![CDATA[<p>This blog is the second part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate API Transformer into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being restricted to [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest/">API Transformer Recipes — Facilitating Migration from SOAP to REST</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="564" class="elementor elementor-564">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-26f17ca9 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="26f17ca9" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-56a7af44" data-id="56a7af44" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-582c502e elementor-widget elementor-widget-text-editor" data-id="582c502e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="alignnone wp-image-565" src="/wp-content/uploads/2021/12/1_tqcLl6LbPrHu3jCAo8rJng.jpg" alt="API Transformer Recipes - Migration from SOAP to REST" width="800" height="350" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="3db3" class=""><em>This blog is the second part of the series called “API Transformer Recipes”. The series aims to highlight numerous ways in which developers can integrate </em><a href="https://www.apimatic.io/transformer"><em>API Transformer</em></a><em> into their workflow in order to gain access to a wide range of tools and frameworks. Hopefully, it will help eliminate any assumptions that they have about being restricted to a particular set of tools just because they use a certain API specification format.</em></p>
<p id="fe7e" class="">Back in 2017, when we launched support for <a href="https://www.w3.org/TR/2001/NOTE-wsdl-20010315">WSDL 1.1</a> in API Transformer, it was not anticipated that a large number of people will transform from files of this format. Mostly because WSDL 1.1 is designed exclusively for SOAP services while the supported output formats mainly describe RESTful services. However, the increasing number of people converting WSDL files on API Transformer made us think twice and compelled us to study this case more deeply. I will be sharing the findings of that in this blog. If you are a SOAP user looking to migrate to REST, I will also be discussing some ways to help you get started today.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<figure id="attachment_566" aria-describedby="caption-attachment-566" style="width: 700px" class="wp-caption aligncenter"><img class="wp-image-566" src="/wp-content/uploads/2021/12/1_r5zeugcyPNokW4Q-B7GV2g.png" alt="Number of WSDL conversions to other formats that support REST (Jan 2017 — Nov 2018)" width="700" height="385" /><figcaption id="caption-attachment-566" class="wp-caption-text">Number of WSDL conversions to other formats that support REST (Jan 2017 — Nov 2018)</figcaption></figure>
</figure>
</div>
<!-- /wp:image --><!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="36ce">SOAP or REST: What is the preferred choice and why?</h2>
<p id="dc1c" class="">The choice between SOAP and REST depends mainly on the requirements of the application being developed. For larger enterprise-level applications, that demand standardization and rely heavily on security, SOAP is still preferred by many. REST, on the other hand, is quickly becoming the popular choice for mobile and web applications where higher performance and lesser complexity takes more priority. It has a smaller learning curve which reduces the time it takes for developers to work on, document and maintain such applications.</p>
<p class="">In most cases, REST relies on JSON for data exchange which has lesser overhead involved as compared to dealing with the highly verbose (and often painfully complex) XML in SOAP. JSON also means better support for browser clients. REST reads can be cached for better performance and scalability.</p>
<p id="f63d" class="">Today, with the ever increasing number of web and mobile applications, the APIs being exposed are largely based on REST+JSON. Such APIs change all the time as businesses adapt to new requirements and REST provides the much needed flexibility. Using SOAP in such cases, with its specific contractual agreements, is likely to add only unnecessary complexity. Due to this, even the developers who have had their services exposed using SOAP APIs are now looking to make them RESTful.</p>
<h2 id="b1db" class="">Will an adapter layer or a proxy service let you REST?</h2>
<p id="a9de" class="">If your SOAP service works over HTTP, some quick solutions to expose your SOAP service as a REST service are:</p>
<ol class="">
<li id="0f60">Add an adapter layer on top of the SOAP service</li>
<li id="3e6c">Add a proxy service for calling the SOAP service.</li>
</ol>
<p id="c8c7" class="">While I won’t be going into the depths of these, both solutions suggested above will have one thing in common: Conversion of any incoming REST requests to SOAP compatible requests (e.g. wrapping the request in a SOAP envelope) and conversion of any outgoing SOAP responses to REST compatible responses (e.g. converting XML responses to JSON).</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<figure id="attachment_567" aria-describedby="caption-attachment-567" style="width: 700px" class="wp-caption aligncenter"><img class="wp-image-567" src="/wp-content/uploads/2021/12/1_o_0QkZjJiEvgUE5htHTq4Q.jpg" alt="Handling REST requests with a converter" width="700" height="190" /><figcaption id="caption-attachment-567" class="wp-caption-text">Handling REST requests with a converter</figcaption></figure>
</figure>
</div>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="f3da" class="">And while these solutions are a good start and will let you get your system into production in no time, they are not very likely to be scalable in the long run. Eventually, a situation will arise when you will have no other choice but to refactor or rewrite your SOAP service using REST.</p>
<h2 id="189c" class="">Start RESTing with API Transformer</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:heading /--><!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-568 aligncenter" src="/wp-content/uploads/2021/12/1_yBAR8Tr9BB1-m8AfBHjing.jpg" alt="" /></p>
</figure>
<!-- /wp:image --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="14ec" class="">So, if the adapter/proxy solution does not work for you and you are looking for a more effective and long-lasting solution, you will have to rethink your model and start building up from there. Sure, it is likely to take more time and would require a lot more manual work but hey, the fruits of hard work are sweet, aren’t they?</p>
<p id="4311" class="">Okay, let’s not despair just yet. API Transformer has got you covered. We can help make your task a little less daunting. How? We let you convert your WSDL files to OpenAPI/Swagger and other formats that support REST. This would give you a head start on the model that you need to work on. Below, I’ll dive into this a little deeper so you get a better idea of what I mean.</p>
<h3 id="6931">WSDL</h3>
<p id="f201" class="">This is a file associated with SOAP often described as a contract between the service provider and its consumer. It provides a complete definition of how the service works including fine grain details of all elements and attributes involved. It also helps dictate restrictions like the order the elements must appear in. Many tools exist that lets you generate method stubs in almost any language if you have the WSDL file with you.</p>
<h3 id="0b39">Formats that support REST</h3>
<p id="e30a" class="">A common question asked is: Is there a WSDL like format for REST? Truth is, there is no one format that describes all kinds of RESTful APIs. Many formats exist that attempt to cover as many aspects as possible. Some of the well-known ones include OpenAPI/Swagger, API Blueprint, RAML, etc. If you are able to get your hands on any one of these, you can benefit from a wide range of tools and frameworks that lets you mock, test APIs as well as auto-generate client/server code.</p>
<h3 id="9009" class="">From WSDL to a more RESTful model with API Transformer</h3>
<p id="6778" class="">As mentioned earlier, API Transformer helps you transform a WSDL file associated with a SOAP service to any of the popular REST-supporting formats. I converted one such file to OpenAPI/Swagger v2.0. The conversion process and output is analyzed below. If you are interested to see the complete files, you can find them <a href="https://github.com/fariadev22/api-transformer-recipes/tree/master/Migration%20from%20SOAP%20to%20REST">here</a>.</p>
<h4 id="d731"><strong><em>1. Service Information</em></strong></h4>
<p id="11f7" class="">During the conversion, service details like the name, documentation and location address are extracted from the WSDL and placed in the relevant Swagger components.</p>
<p id="2818" class=""><strong>WSDL</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:preformatted -->
<pre class=""><code class="language-xml">
  WSDL File for HelloService
  
     
  
</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="7a35" class="">OpenAPI/Swagger</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:preformatted -->
<pre class=""><code class="language-xml">swagger: '2.0'
info:
  version: '1.0'
  title: HelloService
  description: WSDL File for HelloService
host: www.examples.com
basePath: /MessagingService/
schemes:
- http</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="4447" class=""><strong><em>2. WSDL Operation vs Swagger Operation</em></strong></p>
<p id="fde2" class="">WSDL operations are defined in an abstract way inside the port types and their concrete details are provided in the bindings. When mapping these operations to Swagger operations, we try to utilize as much information as possible from both port types and bindings.</p>
<p id="83e8" class=""><strong>WSDL:</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:preformatted -->
<pre class=""><code class="language-xml">
    
       <input type="text" />
       <output></output>
    


    
    
       
       <input type="text" />
          
           
       <output>
          
       </output>
    
 </code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="446e" class=""><strong>OpenAPI/Swagger:</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:preformatted -->
<pre class=""><code class="language-xml">paths:
  /getMessage:
    post:
      summary: getMessage
      tags:
      - Hello_Binding
      operationId: GetMessagePost
      produces:
      - application/json
      parameters:
      - name: Body
        in: body
        required: true
        schema:
          $ref: '#/definitions/GetMessageRequest'
      responses:
        200:
          description: ''
          schema:
            $ref: '#/definitions/GetMessageResponse'</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="7c43">The mapping is not perfect, however:</p>
<p id="913d" class="">According to REST principles, a resource’s relative path should ideally indicate the resource on which the CRUD operations are to be performed. For the conversion from WSDL, this path is extracted from the SOAP operation’s name. However, since SOAP is function-driven, the operation names in WSDL are always function names that don’t always result in the ideal resource path. In the example above, therefore, the resource path <code>/getMessage</code> should have been <code>/message</code> (<code>message</code> being the resource here) with the HTTP verb as being sufficient to indicate the action to be performed on the resource (the <code>get</code> keyword in the path being unnecessary, therefore).</p>
<p id="86af" class=""><strong>b.</strong> For the conversion, we assume that all WSDL operations use <code>POST</code> by default unless the HTTP method is explicitly specified through <a href="https://www.w3.org/TR/2001/NOTE-wsdl-20010315#_http-b">HTTP bindings</a> in the WSDL file. This is because, in all other cases, detecting the correct CRUD operation from WSDL is not directly possible. The output, therefore, may not indicate the ideal HTTP method of the operation e.g. the <code>GetMessagePost</code> Swagger operation is only retrieving an object of the message resource without changing the resource in any way. Based on this, the operation should be using the <code>GET</code> method instead of <code>POST</code>. You will, therefore, be required to manually identify the correct method for all operations and change it in the output.</p>
<p id="5fd7" class=""><strong>c.</strong> REST is designed largely to work over HTTP while SOAP is capable of supporting other protocols as well. Any concrete binding information about other protocols will be lost during the transformation because of incompatibility with RESTful formats e.g. in the above conversion, any information related to the SOAP <code>transport</code> mechanism, binding <code>style</code> and body <code>encoding</code> is lost in the output.</p>
<h4 id="6fa0"><strong><em>3. Namespaces</em></strong></h4>
<p id="ca6b" class="">There is no concept of namespaces in REST whereas WSDL relies heavily on them:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:preformatted -->
<pre class=""><code class="language-xml">
.
.
</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="8f57" class="">In case of types from schemas of different namespaces, we try to preserve some of the namespacing context e.g. in the output the types are named <code>s1_MessageIdentificationInfo</code> and <code>s2_Message</code> where <code>s1</code> and <code>s2</code> are the respective namespace prefixes of the namespaces in which the types existed in the original WSDL.</p>
<p id="806f"><strong>WSDL:</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:preformatted -->
<pre class=""><code class="language-xml">
    


    
</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="f23d" class=""><strong>OpenAPI/Swagger:</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:preformatted -->
<pre class=""><code class="language-xml">GetMessageRequest:
  title: GetMessageRequest
  type: object
  properties:
    messageId:
      $ref: '#/definitions/s1_MessageIdentificationInfo'
  required:
  - messageId
GetMessageResponse:
  title: GetMessageResponse
  type: object
  properties:
    message:
      $ref: '#/definitions/s2_Message'
  required:
  - message</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h4 id="5cc9"><strong><em>4. XML Schema to JSON Schemas</em></strong></h4>
<p id="e2cc" class="">The conversion involves mapping of XML schema content to JSON schemas (or a subset of JSON schemas but that is irrelevant here). Since XML and JSON are not fully compatible with each other, some information will not be fully translated e.g. JSON does not support attributes and due to this the <code>messageId</code> attribute of <code>MessageIdentificationInfo</code> is loaded as a normal field in the output with nothing to indicate its nature as an attribute.</p>
<p id="2760" class=""><strong>WSDL:</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:preformatted -->
<pre class=""><code class="language-xml">
    
        
            
                
                
                            
            
        
    
</code></pre>
<!-- /wp:preformatted --><!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="522f" class=""><strong>OpenAPI/Swagger:</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph --><!-- wp:preformatted -->
<pre class=""><code class="language-xml">s1_MessageIdentificationInfo:
  title: s1_MessageIdentificationInfo
  type: object
  properties:
    messageId:
      type: string
    senderName:
      type: string
    recipientName:
      type: string
  required:
  - messageId
  - senderName
  - recipientName</code></pre>
<!-- /wp:preformatted --><!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="e2b5" class="">Takeaways before you can fully REST</h2>
<p id="011e" class="">As you can see, the conversion isn’t the only step you need to get up and running with a RESTful service because it can only do so much. It provides you with a rough model of what your service can look like which will require additional work before it can be considered fully RESTful. For example, you will have to manually identify the resources involved in your service as well as the CRUD operations that needs to be performed on them besides <code>POST</code>.</p>
<p id="bb46" class="">Kin Lane, from API Evangelist, who once tried experimenting with such conversions summarizes his experience very nicely in his <a href="https://apievangelist.com/2018/01/08/seeing-reflections-from-the-past-rippling-in-the-api-pool-when-translated-wsdl-to-openapi/">blog</a>:</p>
<blockquote class="wp-block-quote">
<p>…I do like having tools that help me make sense of what was, and create a scaffolding for what can be. Then I just dive in and clean up, polish, and move forward as I see fit.</p>
</blockquote>
<p id="9b1a" class="">You will need to keep on molding your model until it attains a shape that suits your application as well as abides by the REST principles. A similar approach was also followed by some of our customers from <a href="https://www.nbc.ca/"> National Bank of Canada </a> who were able to create RESTful models for their SOAP based services using  API Transformer.</p>
<p id="5075" class="">Once you have your model ready, there are tools out there that lets you generate server stubs which can ease the implementation process e.g. you can generate server stubs from Swagger Codegen with a OpenAPI/Swagger file.</p>
<h2 id="7027">Conclusion</h2>
<p id="98aa" class="">If you are ready to make the jump from SOAP to the RESTful world, nobody is stopping you. There are plenty of ways out there to facilitate you in the process. But, don’t jump blindly! Just because everyone is doing it doesn’t mean you have to as well. Establish the need first and then work towards it.</p>
<p id="f733" class="">Continue reading:<br />a) <a href="https://apimatic.io/blog/2018/11/api-transformer-recipes-enabling-postmans-team-sharing-features-for-openapi-users">Part 1 of API Transformer Recipes: Enabling Postman’s Team Sharing Features for OpenAPI Users</a><br />b) <a href="https://apimatic.io/blog/2019/01/api-transformer-recipes-opening-ways-into-ibm-api-connect">Part 3 of API Transformer Recipes — Opening ways into IBM API Connect</a><br />c) <a href="https://apimatic.io/blog/2019/07/moving-to-graphql-from-soap-or-rest">Part 4 of API Transformer Recipes — Moving to GraphQL from SOAP or REST</a><br />d) <a href="https://apimatic.io/blog/2020/06/the-whys-and-hows-of-exposing-a-soap-service-using-your-rest-api">Part 5 of API Transformer Recipes — The Whys and Hows of Exposing a SOAP Service Using Your REST API</a></p>
</div>
</div>
</div>
</div>
<!-- /wp:heading --><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:quote /--><!-- wp:paragraph /--><!-- wp:paragraph /--><!-- wp:heading /--><!-- wp:paragraph /--><!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/2018/12/api-transformer-recipes-facilitating-migration-from-soap-to-rest/">API Transformer Recipes — Facilitating Migration from SOAP to REST</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
