
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Open Api Archives - APIMatic</title>
	<atom:link href="/blog/tag/open-api/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>APIMatic is an API documentation tool that provides a complete set of DX components such as autogenerated SDKs, API portal, API docs, live code samples, and more.</description>
	<lastBuildDate>Mon, 11 Apr 2022 05:37:11 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>

<image>
	<url>/wp-content/uploads/2021/10/cropped-cropped-apimaticio-favicon-1-32x32.png</url>
	<title>Open Api Archives - APIMatic</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>6 Practices to Achieve Consistency across API Specifications</title>
		<link>/blog/6-practices-to-achieve-consistency-across-api-specifications/</link>
					<comments>/blog/6-practices-to-achieve-consistency-across-api-specifications/#respond</comments>
		
		<dc:creator><![CDATA[APIMatic]]></dc:creator>
		<pubDate>Fri, 20 Sep 2019 11:02:52 +0000</pubDate>
				<category><![CDATA[API Documentation]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Design]]></category>
		<category><![CDATA[Open Api]]></category>
		<category><![CDATA[Raml]]></category>
		<category><![CDATA[Swagger]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=666</guid>

					<description><![CDATA[<p>This blog is based on a talk presented at APIMatic’s meet-up&#160;&#160;in San Francisco earlier in the year.&#160; API specifications have become a crucial part of the API life cycle, acting as a gateway to better design, documentation and tooling for your API. Due to the growing popularity of API specifications, more and more organizations are [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/6-practices-to-achieve-consistency-across-api-specifications/">6 Practices to Achieve Consistency across API Specifications</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="666" class="elementor elementor-666">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-e60d326 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="e60d326" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1fa8c7cd" data-id="1fa8c7cd" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-2d4278a2 elementor-widget elementor-widget-text-editor" data-id="2d4278a2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
			<style>/*! elementor - v3.6.2 - 04-04-2022 */
.elementor-widget-text-editor.elementor-drop-cap-view-stacked .elementor-drop-cap{background-color:#818a91;color:#fff}.elementor-widget-text-editor.elementor-drop-cap-view-framed .elementor-drop-cap{color:#818a91;border:3px solid;background-color:transparent}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap{margin-top:8px}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap-letter{width:1em;height:1em}.elementor-widget-text-editor .elementor-drop-cap{float:left;text-align:center;line-height:1;font-size:50px}.elementor-widget-text-editor .elementor-drop-cap-letter{display:inline-block}</style>				<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-667 aligncenter" src="/wp-content/uploads/2021/12/1_BYxuxcs43uZuq_Dwuti2ZQ-1024x512.jpg" alt="6 Practices to Achieve Consistency across API Specifications" width="1024" height="512"></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<blockquote>
<p class="">This blog is based on a talk presented at APIMatic’s <a href="https://youtu.be/hBDDc_qhnU4">meet-up&nbsp;&nbsp;in San Francisco</a> earlier in the year.&nbsp;</p>
</blockquote>
<p id="fe62" class="">API specifications have become a crucial part of the API life cycle, acting as a gateway to better design, documentation and tooling for your API.</p>
<p id="5660" class="">Due to the growing popularity of API specifications, more and more organizations are moving towards spec-driven development. In this process, API are designed before built, so that any flaws and inconsistencies are recognized early on and fixed before the development. The approach ensures you stay on budget and avoid snags that can come from miscommunication.</p>
<p id="e125" class="">While a spec may ensure that there are no hiccups while developing APIs, the document itself is prone to inconsistencies and errors. Multiple stakeholders including developers, product owners, and technical writers contribute to the spec, and with all of them bringing in their own flavor and style, it often ends up looking like a mess.</p>
<p id="6a58" class="">Moreover, a spec is more than just a design artifact, it serves as a gateway to various API tooling throughout the API lifecycle. Many of the API Design, Management, Testing, Deployment, and Documentation tools today take API Specifications as input to work on the API, and unless free of flaws and contradictions, a spec can never be rendered in an efficient or effective manner.</p>
<p id="e314" class="">It’s therefore essential to have a set of guidelines to ensure the document remains free of conflicting styles and formats and is produced in one cohesive manner. This blog will cover a few of these guidelines and practices that you can follow to achieve consistency across the API Specification workflow while keeping it functional and agile.</p>
<h2 id="358a"><strong>1. Create a Style Guide</strong></h2>
<p id="8a35">Often organisations have a style guide for designers and writers to follow when producing branding content and material. In a similar fashion, all API teams should develop a style guide for writing API Specifications. And it should be enforced as a uniform practise throughout the organisation. The guide should recommend what sort of conventions and practices are to be used when contributing to the specification.</p>
<p id="e581" class="">For instance, often it’s unclear if:</p>
<ul class="">
<li>Schemas should have examples</li>
<li>In-line schemas are permissible</li>
<li>Operations must have descriptions</li>
<li>Parameters and responses restricted to certain types or numbers</li>
</ul>
<p id="8cdd" class="">Similarly, in many more cases like that, contributors whenever in doubt, just work with a style they are used to or comfortable with. The easy way out is to standardize these practices, and recommend a way which guides contributors from all departments to make additions in a uniform manner.</p>
<p id="35a2" class="">To ensure that the recommended practices are being followed, and no conflicts make through to the actual document, validators should be set up that verify if the addition is aligned with the recommended style. This can be executed with Linters, a popular linting tool for specs is “<a href="https://github.com/wework/speccy">Speccy</a>”, which takes your custom rules and runs the specs against it, validating it against those rules.</p>
<p id="c2bc" class="">Building validation into the CI/CD cycle further streamlines the process, so whenever updates are pushed to your API, they first go through these checks so that nothing of varying nature is added to your specification.</p>
<h2 id="4a8c"><strong>2. Promote Visibility and Reusability</strong></h2>
<p id="26b6" class="">Another common practice and really a nice one is to publish your API specs to Version Control for across board visibility. Make them available on a master repository and create a pull request mechanism, allowing nothing to pass to the central repository without a review, while still allowing contributors to view and make use of each and every contribution.</p>
<p id="9d76" class="">A big part of the specification is the schema itself, many organizations today are using JSON schema to define those specifications, even though OpenAPI has a schema that is subset of JSON schema, but JSON schema has very good tooling around it and in many more numbers. Defining models in JSON schema would make the spec very versatile and open-ended.</p>
<p id="892e" class="">You can again use Speccy to convert JSON schema to OAS schemas. This would allow you two things:</p>
<ul class="">
<li><strong>Keeping your schema separate from API specifications</strong></li>
</ul>
<p id="f7de">You have a new team and they want to use the same object the other team is using, from going to actually write it from hand again, and having discrepancies, you can use the same schema, just refer it in your spec.</p>
<ul class="">
<li><strong>Validating API specifications</strong></li>
</ul>
<p id="725f" class="">With JSON Schema Linting, you can write better tests. Resulting in better validation of schema.</p>
<p id="4ffb" class="">And for every artifact you are creating, schema or the spec, version them, so once your program scales, you know what version your API team is dependent on.</p>
<h2 id="5493"><strong>3. Separate API Design from Documentation</strong></h2>
<p id="f93c" class="">A specification is normally maintained by API developers, they are the people responsible for putting in what the requests are, what the endpoints are, how the responses would look like, basically the people turning an API into reality, but there is also a team of tech writers who work on the spec to add documentation, sample code, guides and tutorials, and all sort of help material to make sure that the API human-readable and usable.</p>
<p id="350e">To allow both the development and documentation team to work simultaneously, you can maintain documentation and tutorials as a separate project while the developers work on the spec to make changes to design</p>
<p id="6948" class="">There’s a concept of&nbsp;<strong>overlays</strong>, which has already been introduced in RAML and is still being talked about in OpenAPI Spec, and we here at APIMatic are actually building this out in our own format. What Overlays essential does is allow separation of these two concerns, letting your tech writers work independently so that any drastic change made to the specification does not affect them. The two can be merged later to make a comprehensive API reference.</p>
<h2 id="1af4" class=""><strong>4. Tag your Operations</strong></h2>
<p id="9fdc" class="">Another great practice is tagging your operations with groups and status and creating multiple versions of the same spec, for instance: Dev, Public, Partner, and Internal for different stakeholders. With this, a team can work on the same spec without creating multiple versions, and expose only the portions of that spec to the people they want it to be exposed. While exposing an Internal API, out of many hundreds of endpoints, choose the ones you want to make public while keeping the original spec as a single source of truth.</p>
<h2 id="8cbb" class=""><strong>5. Merge your API Specifications</strong></h2>
<p id="a227" class="">As your API team expands, you have multiple teams working on different services, the recommended practice is that specs for those services are maintained independently. Developers working on those services, as soon as they are done the building, update the spec and get it out. However, maintaining these services and specs separately does not mean they have to be exposed to the user in a similar fashion. Merging these different specs into a single unified one can provide the advantage of presenting a single view, single documentation, single library, and a single mock service.</p>
<p id="6a5c" class="">Few specification formats, especially the OpenAPI format is flexible enough to achieve this and anybody get a pipeline running by just writing a script. But the tool that we are working on at APIMatic will be able to merge any specification into a single one regardless of the format and the nature of it.</p>
<h2 id="8879" class=""><strong>6.</strong> Generate<strong> Changelogs</strong></h2>
<p id="b808" class="">This is another form of validation that you can achieve before making your specification public. Let’s say a developer comes in and makes an optional parameter, required. Now that would make things different for the user, and would not want this released without a version bump or release notes.</p>
<p id="bdb6" class=""><a href="https://github.com/Sayi/swagger-diff">Swaggerdiff</a>&nbsp;is a tool that can help you avoid that. Although it can work with just OpenAPI formats, for now, you can always make use of API Transformer to convert your spec to the format it supports and then run rests for your specifications to detect breaking and minor changes, which can be rendered in form of change-logs. A little work by your documentation team and they’d be good to go for your audiences as well.</p>
<h2 id="cee6" class="">What’s Next?</h2>
<p id="ca0a" class="">Now that you know what practices you need to follow to make sure the Spec is produced in a neat, clean and well-organized manner, it’s now time to consider the big question. What can you do with that spec, or why do you need such a well-rounded spec in the first place? Stay tuned for the next blog in line, which will discuss what can be done with a great-looking API specification.</p>
</div>
</div>
</div>
</div>
<!-- /wp:embed -->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/6-practices-to-achieve-consistency-across-api-specifications/">6 Practices to Achieve Consistency across API Specifications</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/blog/6-practices-to-achieve-consistency-across-api-specifications/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>A Year with API Transformer</title>
		<link>/blog/a-year-with-api-transformer/</link>
					<comments>/blog/a-year-with-api-transformer/#respond</comments>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 20 Apr 2018 10:53:46 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Specs]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[Open Api]]></category>
		<category><![CDATA[Usage Trends]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=592</guid>

					<description><![CDATA[<p>Developers today are actively seeking relevant tools and frameworks in order to make their API design and consumption process as easy and efficient as possible. An important part of this process is describing the API in any of the available specification formats. And since each of the API description formats come with their own toolset, [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/a-year-with-api-transformer/">A Year with API Transformer</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="592" class="elementor elementor-592">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-20b0caaf elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="20b0caaf" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-220cb7e" data-id="220cb7e" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-4c8a6d4e elementor-widget elementor-widget-text-editor" data-id="4c8a6d4e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-593 aligncenter" src="/wp-content/uploads/2021/12/1_NUcBLHXepZNfgEswFi9UzA.jpg" alt="A Year with API Transformer 2017" width="1000" height="400"></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="15dd" class="">Developers today are actively seeking relevant tools and frameworks in order to make their API design and consumption process as easy and efficient as possible. An important part of this process is describing the API in any of the available specification formats. And since each of the API description formats come with their own toolset, the need to be able to convert between different formats is growing rapidly. This is where <a href="https://www.apimatic.io/transformer">API Transformer</a> comes into play. It offers a tool called “<strong>Convertron</strong>” which has helped many users transform their API description files from one format to another. Many popular formats like&nbsp;<a href="https://swagger.io/specification/">OpenAPI</a>, <a href="https://raml.org/">RAML</a>, etc. are supported.</p>
<p id="3fb9" class="">Over the years, API Transformer has evolved quite a lot. In particular, the year 2017 saw some important additions to the tool like the <a href="https://apimatic.io/blog/2017/05/apimatic-turns-3-announcing-support-of-oas-3-0">newly added support for OpenAPI 3</a>&nbsp; and WSDL. Many improvements were also made to the existing format parsers in which, without any doubt, the valuable feedback from our amazing users played a vital role. The year has flown away but has left behind some interesting trends and patterns that we plan to share with you today in this blog.</p>
<h2 id="38fc" class="">Trends from 2017</h2>
<p id="076a" class="">For each aspect, two kinds of data will be analyzed. One will take into account all events that occurred irrespective of the users performing these events. However, we have a handful of users who perform thousands of conversions every month. The first data gets largely skewed because of these conversions. So in the second data, to get a better picture, we try to remove this skewed behavior of the data by considering only unique events per user.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_594" aria-describedby="caption-attachment-594" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-594" src="/wp-content/uploads/2021/12/1_nPsR6Mra5k2662q79wtUKA-1024x268.png" alt="Transformer Usage 2017" width="1024" height="268"><figcaption id="caption-attachment-594" class="wp-caption-text">Transformer Usage 2017</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class="has-text-align-center"><strong>Most Common Formats Brought In By Developers</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_597" aria-describedby="caption-attachment-597" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-597" src="/wp-content/uploads/2021/12/1_hgXyTyoyGGuFaIdl79_UsA-2-1024x498.png" alt="Total vs Unique Analysis of Most Common Formats Imported" width="1024" height="498"><figcaption id="caption-attachment-597" class="wp-caption-text">Total vs Unique Analysis of Most Common Formats Imported</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="3b19" class="">Out of the total imported files on Transformer (approximately 94,000), 50% were Postman 1.0 files, 25% were Postman 2.X while only 6% were OpenAPI 2.0. The second graph does not consider redundant format conversions per user e.g. if a user converted fifty Postman 1.0 and ten OpenAPI 2.0 files, he converted two unique format files (one Postman and one OpenAPI). Elimination of this redundancy shows that 24% of the imported files were defined using OpenAPI 2.0, 20% were using Postman 2.X while 10% were using WSDL. The rest falls in the smaller chunks. So the most common formats brought in by developers were&nbsp;<strong>OpenAPI</strong>&nbsp;and&nbsp;<strong>Postman</strong>.</p>
<h2 id="239f" class=""><strong>Most Common Formats Developers Loved Exporting To</strong></h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_598" aria-describedby="caption-attachment-598" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-598" src="/wp-content/uploads/2021/12/1_ZxiFUSv6zuu6dZbmD4xGWQ-1024x511.png" alt="Total vs Unique Anaylsis of Most Common Formats Exported" width="1024" height="511"><figcaption id="caption-attachment-598" class="wp-caption-text">Total vs Unique Analysis of Most Common Formats Exported</figcaption></figure>
</figure>
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="49b5" class="">52% of the API description files were exported to API Blueprint while 35% to OpenAPI 2.0. Eliminating multiple exports to the same format per user, we observed that 55.5% of the files were exported to OpenAPI 2.0 while 9% to RAML 1.0. API Blueprint was not very dominant in this second case. Overall,&nbsp;<strong>OpenAPI 2.0</strong>&nbsp;seemed to take the lead for the format that developers wanted to play around with.</p>
<p id="49b5" class="">The choice of the format when exporting could have been related to several factors like size of the community, tools, and frameworks available, strong documentation, and availability of a newer and stable version with more features, to name a few. OpenAPI 2.0 and Postman 2.0/2.1 are a natural preference over their older versions (OpenAPI 1.2, Postman 1.0). Very few users prefer to export to WADL or WSDL because of limited usage and tooling.</p>
<h2 id="8dfa">Most Common Format Conversions</h2>
</div>
</div>
</div>
</div>
<!-- /wp:image -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_600" aria-describedby="caption-attachment-600" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-600" src="/wp-content/uploads/2021/12/1_ZQQsPA96_vXC2uzHXHdzUA-1-1024x383.png" alt="Total vs Unique Analysis of Top Ten Format Conversions" width="1024" height="383"><figcaption id="caption-attachment-600" class="wp-caption-text">Total vs Unique Analysis of Top Ten Format Conversions</figcaption></figure>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="fe70" class="">We also looked at the top ten import-export mappings to understand which conversions are most popular. For the total conversions performed, the most common conversion seen was from Postman 1.0 to API Blueprint (approx 45,000 conversions) whereas if we eliminate non-unique mappings per user, import from&nbsp;<strong><em>Postman 2.X to OpenAPI 2.0</em></strong>&nbsp;was found to be the most common (approx 530). This shows that a lot of developers prefer Transformer for converting&nbsp;<strong>from Postman to other API description formats</strong>.</p>
<h2 id="4312">Geographical Usage of Formats</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_601" aria-describedby="caption-attachment-601" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-601" src="/wp-content/uploads/2021/12/1_WP6Umd8XIusdVoxazoqtQw-1024x352.png" alt="Total vs Unique Analysis of Geographical Usage of Formats" width="1024" height="352"><figcaption id="caption-attachment-601" class="wp-caption-text">Total vs Unique Analysis of Geographical Usage of Formats</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="e7b3" class="">From the above graphs, you can see that users of Transformer are distributed far and wide into various geographical regions of the world. We had some users performing thousands of conversions every month from India and they constitute 52% of the total conversions represented in the first case. If multiple conversions from the same location per user are ignored, we see that 24% of the conversions occurred from the US while only 10% were performed from India. Hence, the majority of our users using Transformer in 2017 were based in the <strong>US and India.</strong></p>
<p id="019a">Note that for these graphs we eliminated data of conversions in which the locations were unknown.</p>
<h2 id="5dee" class="">Most Common Formats That Failed To Transform</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_602" aria-describedby="caption-attachment-602" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-602" src="/wp-content/uploads/2021/12/1_KOksY86ZTLjamtrzlxjHrw-1024x515.png" alt="Total vs Unique Analysis of Most Common Format Failures" width="1024" height="515"><figcaption id="caption-attachment-602" class="wp-caption-text">Total vs Unique Analysis of Most Common Format Failures</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="d223" class="">Some of the users failed to transform their files (approx 8,000 which is roughly 8% of the total conversions performed). 35% of the total failed conversions were invalid/unsupported (more on this later) while 30% were RAML files (0.8/1.0) and 18% were OpenAPI files (1.X/2.0). By removing redundant failures of the same format per user, a big 44% of the chunk of failures belonged to the invalid/unsupported, 20% belonged to RAML(0.8/1.0) while 17% were OpenAPI files (1.X/2.0).</p>
<p id="2370" class="">As you can see, a large portion of failures constitutes of the&nbsp;<strong>invalid/unsupported files</strong>. These were the files which were either:</p>
<ul class="">
<li id="4bfe">Not valid API description files e.g. HTML files, JSON response data, XML schema files OR</li>
<li id="3c2a">Supported by Transformer but lacked necessary metadata that prevented proper identification e.g. API Blueprint files without “Format” and “Host” information. Some common mistakes also prevented proper identification of the files (invalid JSON, incomplete file, etc.) OR</li>
<li id="3663">Not supported by Transformer in 2017 e.g. Insomnia</li>
</ul>
<p id="aba8" class="">The rest of the conversions are largely attributed to&nbsp;<strong>RAML or OpenAPI</strong>&nbsp;files. A common cause for these is uploading a file containing external references without providing these references within the specification file.</p>
<h2 id="8308">Transformations via Web vs Transformations via API</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_603" aria-describedby="caption-attachment-603" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-603" src="/wp-content/uploads/2021/12/1_WpsbcgB_75hO87-D9AXkMA-1024x438.png" alt="Total vs Unique Comparison of Transformer Web and API Conversions" width="1024" height="438"><figcaption id="caption-attachment-603" class="wp-caption-text">Total vs Unique Comparison of Transformer Web and API Conversions</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="9192" class="">API Transformer not only provides a web UI to users for performing conversions but also facilitates them by providing a simple API that offers the same functionality as the UI. In 2017, 76% of the total conversions were made using the API. However, by considering only unique web/API conversions per user shows that&nbsp;<strong>96% of the conversions were made using the web interface</strong>.</p>
<h2 id="99c8">Size of the APIs</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<figure id="attachment_604" aria-describedby="caption-attachment-604" style="width: 718px" class="wp-caption aligncenter"><img class="wp-image-604" src="/wp-content/uploads/2021/12/1_TiawMyqOHqW0zjam3qmnfQ.png" alt="Analysis of Size of API for Total Conversions" width="718" height="445"><figcaption id="caption-attachment-604" class="wp-caption-text">Analysis of Size of API for Total Conversions</figcaption></figure>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="e1ee" class="">For measuring the size of an API, we considered the number of endpoints in an API. Pretty much all the APIs had less than 300 endpoints. However, a very small portion (0.39% of the total conversions and 2.61% of the unique conversions per user) of large APIs also existed that had endpoints ranging above 300.</p>
<h2 id="e9bd">Conclusion</h2>
<p id="5fe9" class="">2017 was no doubt an exciting year offering intriguing insights into<a href="https://www.apimatic.io/transformer"> API Transformer</a>. This year we plan to make Transformer even better by adding other commonly used formats like&nbsp;&nbsp;Insomnia and by improving other areas of it as well. So, stay tuned!</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/a-year-with-api-transformer/">A Year with API Transformer</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/blog/a-year-with-api-transformer/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Common Mistakes Developers Make In Their OpenAPI 3 Files</title>
		<link>/blog/common-mistakes-developers-make-in-their-openapi-3-files/</link>
					<comments>/blog/common-mistakes-developers-make-in-their-openapi-3-files/#respond</comments>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 09 Mar 2018 10:53:46 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Specs]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[Developers]]></category>
		<category><![CDATA[Open Api]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=561</guid>

					<description><![CDATA[<p>OpenAPI 3 (OAS 3) is the latest iteration of the OpenAPI Specification.&#160;APIMatic has been supporting the format since it was still a release candidate. With adoption rates for OAS 3 going up, we noticed a few common mistakes developers are prone to make. Majority of these relate to the way certain features worked with OAS [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/common-mistakes-developers-make-in-their-openapi-3-files/">Common Mistakes Developers Make In Their OpenAPI 3 Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="561" class="elementor elementor-561">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-4cc673ec elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="4cc673ec" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-5e480934" data-id="5e480934" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-4b49bdc8 elementor-widget elementor-widget-text-editor" data-id="4b49bdc8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class="">OpenAPI 3 (OAS 3) is the latest iteration of the OpenAPI Specification.&nbsp;<a href="https://apimatic.io/blog/2017/05/apimatic-turns-3-announcing-support-of-oas-3-0">APIMatic has been supporting the format</a> since it was still a release candidate. With adoption rates for OAS 3 going up, we noticed a few common mistakes developers are prone to make. Majority of these relate to the way certain features worked with OAS 2.0 (more commonly known as Swagger 2.0) but require a different approach with OAS 3.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_562" aria-describedby="caption-attachment-562" style="width: 978px" class="wp-caption aligncenter"><img class="wp-image-562" src="/wp-content/uploads/2021/12/1_8gRmupEoR2NxC_uwstwhSw.png" alt="Common Mistakes Developers Make In Their OpenAPI 3 Files" width="978" height="490"><figcaption id="caption-attachment-562" class="wp-caption-text">Mistakes Found In OAS 3 Files During Conversions On&nbsp;API Transformer</figcaption></figure>
</figure>
<!-- /wp:image -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="284d" class="">Using the old “<code>swagger”</code>&nbsp;property to specify OpenAPI version</h2>
<p id="2472" class="">A Swagger user, who has had his hands dirty with version 2.0, would usually specify Swagger version using the&nbsp;<code>swagger</code>&nbsp;property as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-json">{
  &quot;swagger&quot;: &quot;2.0&quot;
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="029b" class="">When migrating towards OAS 3, developers are still seen using the same property to specify the version of the newer format.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-json">{
  &quot;swagger&quot;: &quot;3.0.0&quot;
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="660f" class="">This is&nbsp;<strong>invalid</strong>&nbsp;as OAS 3 has now replaced that with the new&nbsp;<code>openapi</code>&nbsp;<a href="https://swagger.io/specification/#openapi-object-17">property</a> which makes use of semantic versioning.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-json">{
  &quot;openapi&quot;: &quot;3.0.0&quot;
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="7892" class="">Defining body parameter in the “parameters”</h2>
<p id="bd42" class="">Remember how Swagger 2.0 let you define a&nbsp;<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameter-object">body parameter</a>&nbsp;in the operation&nbsp;<code>parameters</code>&nbsp;using location set to&nbsp;<code>body</code>? Compared to parameters located elsewhere (query, header, path, formData), this parameter had less restrictions and used a schema object for type definition. OAS 3 decided to separate this parameter for good and let it have its own place in&nbsp;<code>requestBody</code>. The form parameters are also covered under this new property. But developers are still bent on defining the body parameter in the&nbsp;<code>parameters</code>&nbsp;section.&nbsp;<em>Sigh.</em><br><br>This is now&nbsp;<strong>invalid</strong>&nbsp;in OAS 3:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;parameters&quot;: [
 {
   &quot;name&quot;: &quot;body&quot;,
   &quot;in&quot;: &quot;body&quot;,
    &quot;schema&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
 },
 {
   &quot;name&quot;: &quot;petId&quot;,
   &quot;in&quot;: &quot;path&quot;,
   &quot;schema&quot;: {
      &quot;type&quot;: &quot;string&quot;
   }
 }]</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="9d4f">The correct way is to instead use&nbsp;<code>requestBody</code>&nbsp;for form and body parameters:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;parameters&quot;: [
 {
   &quot;name&quot;: &quot;petId&quot;,
   &quot;in&quot;: &quot;path&quot;,
   &quot;schema&quot;: {
     &quot;type&quot;: &quot;string&quot;
   }
 }],
&quot;requestBody&quot;:{
&quot;content&quot;: {
  &quot;text/plain&quot;: {
    &quot;schema&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
   }
 }
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="7b70" class="">Declaring response headers as a list of Header objects</h2>
<p id="8535" class="">It looks like some developers are trying to generate their OAS 3 files from 3rd party tools that do not fully conform to the OAS standards. This results in inaccurate header objects. The&nbsp;<a href="https://swagger.io/specification/#response-object-71">specification</a>&nbsp;states that the response headers must be:</p>
<p id="9f02">1) A map with header name as key and Header object as value&nbsp;<strong>OR</strong></p>
<p id="5da3" class="">2) A map with header name as key and a Reference object as value (that basically would still point to a Header object).</p>
<p id="a288" class="">This implies that an array of header objects or an array of reference header objects can, therefore, not be used but the mistake is still seen quite commonly. Also, the Swagger editor itself does not seem to complain in either case.</p>
<p id="313a">So essentially this is&nbsp;<strong>invalid</strong>&nbsp;(at least as per the spec):</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;responses&quot;: {
   &quot;200&quot;: {
      &quot;description&quot;: &quot;Response for content that consists of a single part.&quot;,
       &quot;headers&quot;: [
       {
         &quot;$ref&quot;: &quot;#/components/headers/HeaderName&quot;
       }]
   }
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>The valid way is to use a map instead:</p>
<pre class=""><code class="language-json">&quot;responses&quot;: {
   &quot;200&quot;: {
      &quot;description&quot;: &quot;Response for content that consists of a single part.&quot;,
     &quot;headers&quot;: {
       &quot;HeaderName&quot;: {
          &quot;$ref&quot;: &quot;#/components/headers/HeaderName&quot;
        }
     }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="e448">Referencing an undefined OAS 3 component</h2>
<p id="f657" class="">Last but not the least, developers often reference an OAS 3 component (definition of a schema, parameter, response, header or a security scheme, etc.) but they don’t define this component in the relevant section of the root <code>components</code>&nbsp;<a href="https://swagger.io/specification/#componentsObject">object</a>. So for example, an OAS 3 response in the API file may be referencing a schema definition like:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;responses&quot;: {
   &quot;200&quot;: { 
      &quot;content&quot;: {
         &quot;application/json&quot;: {
           &quot;schema&quot;: {
             &quot;$ref&quot;: &quot;#/components/schemas/pet&quot; 
           }
         }
      }
    }
 }</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>This requires a definition for&nbsp;<code>pet</code>&nbsp;to be present under the&nbsp;<code>schemas</code>&nbsp;property that itself would lie inside the root&nbsp;<code>components</code><a href="https://swagger.io/specification/#componentsObject">property</a> as follows:</p>
<pre class=""><code class="language-json">&quot;components&quot;: {
   &quot;schemas&quot;: {
      &quot;pet&quot;: {
         &quot;type&quot;: &quot;object&quot;,
         &quot;properties&quot;: {
           &quot;propertyName&quot;: {
              &quot;type&quot;: &quot;string&quot;
            }
          }
       }
    }
}</code></pre>
<p id="3c66" class="">A lot of users forget to define some of these referenced components. Do ensure that any such references you make to components using <code>$ref</code> are resolvable to avoid issues with tools that use this format.</p>
</div>
</div>
</div>
</div>
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="ca92" class="">Conclusion</h2>
<p id="d0ea" class="">As of date, there is no official JSON schema available for OAS 3. With the release of JSON schema, we can expect better validation of OAS 3 files, which will ultimately lead to OAS 3 tools and services becoming more stable and consistent. It’s only then that the probability of such mistakes occurring will decline.</p>
<p id="a6b7" class="">Have OAS files of your own? Head over to&nbsp;<a href="https://www.apimatic.io/transformer">Transformer</a> and start converting to other formats.&nbsp;</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/common-mistakes-developers-make-in-their-openapi-3-files/">Common Mistakes Developers Make In Their OpenAPI 3 Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/blog/common-mistakes-developers-make-in-their-openapi-3-files/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
