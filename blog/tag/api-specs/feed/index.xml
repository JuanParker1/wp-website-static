
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Api Specs Archives - APIMatic</title>
	<atom:link href="/blog/tag/api-specs/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>APIMatic is an API documentation tool that provides a complete set of DX components such as autogenerated SDKs, API portal, API docs, live code samples, and more.</description>
	<lastBuildDate>Mon, 11 Apr 2022 05:37:11 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>

<image>
	<url>/wp-content/uploads/2021/10/cropped-cropped-apimaticio-favicon-1-32x32.png</url>
	<title>Api Specs Archives - APIMatic</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>OpenAPI 3.1 &#8211; What&#8217;s New, and How to Migrate to/from Other API Specs?</title>
		<link>/blog/migrating-to-and-from-openapi-3-1/</link>
					<comments>/blog/migrating-to-and-from-openapi-3-1/#respond</comments>
		
		<dc:creator><![CDATA[Ali Raza]]></dc:creator>
		<pubDate>Tue, 21 Sep 2021 12:40:43 +0000</pubDate>
				<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[APIMATIC]]></category>
		<category><![CDATA[OpenAPI]]></category>
		<category><![CDATA[Releases]]></category>
		<category><![CDATA[API Specification]]></category>
		<category><![CDATA[Api Specs]]></category>
		<category><![CDATA[APIMatic Supported Specs]]></category>
		<category><![CDATA[OpenAPI 3.1]]></category>
		<guid isPermaLink="false">https://apimatic.io/blog/?p=1461</guid>

					<description><![CDATA[<p>The OpenAPI Initiative announced the latest API specification format OpenAPI 3.1 earlier this year. OpenAPI 3.1 introduces multiple new functionalities and improvements compared to the previous OpenAPI versions, which is why this upgrade is expected to have a higher adoption rate. We are excited to announce the support for OpenAPI 3.1 as APIMatic’s latest supported [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/migrating-to-and-from-openapi-3-1/">OpenAPI 3.1 &#8211; What&#8217;s New, and How to Migrate to/from Other API Specs?</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1461" class="elementor elementor-1461">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-2a51f48e elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="2a51f48e" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-30d8c0c6" data-id="30d8c0c6" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-6b60005c elementor-widget elementor-widget-text-editor" data-id="6b60005c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
			<style>/*! elementor - v3.6.4 - 13-04-2022 */
.elementor-widget-text-editor.elementor-drop-cap-view-stacked .elementor-drop-cap{background-color:#818a91;color:#fff}.elementor-widget-text-editor.elementor-drop-cap-view-framed .elementor-drop-cap{color:#818a91;border:3px solid;background-color:transparent}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap{margin-top:8px}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap-letter{width:1em;height:1em}.elementor-widget-text-editor .elementor-drop-cap{float:left;text-align:center;line-height:1;font-size:50px}.elementor-widget-text-editor .elementor-drop-cap-letter{display:inline-block}</style>				<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12" data-wp-editing="1">
<p class=""><img class="aligncenter wp-image-1474" src="/wp-content/uploads/2021/12/introducing-openapi-3-1-in-apimatic-1024x538.png" alt="OpenAPI 3.1 - What's New and How to Migrate to/from Other API Specs? " width="535" height="281"></p>
<p class=""><span style="font-weight: 400;">The OpenAPI Initiative </span><a href="https://www.openapis.org/blog/2021/02/18/openapi-specification-3-1-released"><span style="font-weight: 400;">announced</span></a> <span style="font-weight: 400;">the latest API specification format </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md"><span style="font-weight: 400;">OpenAPI 3.1</span></a><span style="font-weight: 400;"> earlier this year. OpenAPI 3.1 introduces multiple new functionalities and improvements compared to the previous OpenAPI versions, which is why this upgrade is expected to have a higher adoption rate.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">We are excited to announce the support for OpenAPI 3.1 as APIMatic’s latest supported API specification format, which can be used throughout </span><a href="https://www.apimatic.io/"><span style="font-weight: 400;">APIMatic</span></a><span style="font-weight: 400;">’s solutions like API transformation, API Portal generation, and SDK generation.</span></p>

<h2 class=""><strong>How Does APIMatic Support OpenAPI 3.1?</strong></h2>
<p class=""><span style="font-weight: 400;">OpenAPI 3.1 can be used in APIMatic to perform any API transformation or to generate API portals and SDKs.</span></p>

<h3 class=""><strong>API Specification Transformation</strong></h3>
<p class=""><span style="font-weight: 400;">APIMatic supports transformations between different API specification formats. If you haven’t jumped on the OpenAPI 3.1 bandwagon yet, you can transform your existing API definition file into OAS 3.1, or convert an OpenAPI 3.1 file to any </span><a href="https://www.apimatic.io/transformer/#supported-formats"><span style="font-weight: 400;">supported format</span></a><span style="font-weight: 400;">.</span></p>

<h3 class=""><strong>API Portal and SDK Generation</strong></h3>
<p class=""><span style="font-weight: 400;">APIMatic’s Code Generator and Docs Generator also support OpenAPI 3.1 definition files. You can import your OpenAPI 3.1 file so as to generate the developer-friendly </span><a href="https://www.apimatic.io/developer-experience-portal/"><span style="font-weight: 400;">API Portal</span></a> <span style="font-weight: 400;">or to generate feature-rich SDKs in any </span><a href="https://docs.apimatic.io/generate-sdks/supported-sdk-version-dependencies/#supported-sdk-language-versions"><span style="font-weight: 400;">language supported</span></a> <span style="font-weight: 400;">by APIMatic.</span></p>

<h2 class=""><strong>Behind the Scenes of Mapping OpenAPI 3.0 to OpenAPI 3.1 in APIMatic</strong></h2>
<p class=""><span style="font-weight: 400;">Let’s dive in to see the process of how each component of OpenAPI 3.0 is actually mapped to the corresponding component in OpenAPI 3.1 with </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">APIMatic Transformer</span></a><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">The major difference between both formats is related to the </span><b>Schema Object</b><span style="font-weight: 400;">. Previously, the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#schemaObject"><span style="font-weight: 400;">OpenAPI 3.0 Schema Object</span></a> <span style="font-weight: 400;">was an extended subset of JSON Schema Specification </span><a href="http://json-schema.org/"><span style="font-weight: 400;">Wright Draft 00</span></a><span style="font-weight: 400;">, however, the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schemaObject"><span style="font-weight: 400;">OpenAPI 3.1 Schema Object</span></a><span style="font-weight: 400;"> is a superset of JSON Schema Specification </span><a href="https://datatracker.ietf.org/doc/html/draft-bhutton-json-schema-00"><span style="font-weight: 400;">Draft 2020-12</span></a><span style="font-weight: 400;"> by default</span><span style="font-weight: 400;">.</span></p>
<p class=""><span style="font-weight: 400;">Having said that,</span><span style="font-weight: 400;"> you can also use any valid JSON Schema as a Schema Object in OpenAPI 3.1 with </span><a href="http://json-schema.org/understanding-json-schema/reference/schema.html#:~:text=A%20version%20of%20JSON%20Schema,new%20dialect%20of%20JSON%20Schema."><span style="font-weight: 400;">JSON Schema Dialect</span></a><span style="font-weight: 400;"> declared in either JSON Schema or in </span><code>jsonSchemaDialect</code><span style="font-weight: 400;">&nbsp;field in the root OpenAPI 3.1 specification, for that matter.</span></p>
<span style="font-weight: 400;">Now let’s start looking into the mapping of some of the most widely used components of OpenAPI 3.0 to OpenAPI 3.1 one by one:</span>
<h3 class=""><strong>Root Object</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI 3.1 has two additional root components </span><code>jsonSchemaDialect</code><span style="font-weight: 400;"> and </span><code>webhooks</code><span style="font-weight: 400;">&nbsp;as shown in the diagram below.</span></p>
<p class=""><span style="font-weight: 400;">APIMatic Transformer sets <code>jsonSchemaDialect</code> </span><span style="font-weight: 400;">&nbsp;to “</span><a href="https://json-schema.org/draft/2020-12/schema"> <code>https://json-schema.org/draft/2020-12/schema</code></a><span style="font-weight: 400;">” in the exported OpenAPI 3.1 file since the exported file always contains Schema Objects which conform to JSON Schema Specification Draft 2020-12.</span></p>


<figure id="attachment_1467" aria-describedby="caption-attachment-1467" style="width: 581px" class="wp-caption aligncenter"><img class="wp-image-1467 " src="/wp-content/uploads/2021/12/root-objects.png" alt="Difference between Root Objects of OpenAPI 3.0 and OpenAPI 3.1" width="581" height="418"><figcaption id="caption-attachment-1467" class="wp-caption-text">Difference between Root Objects of OpenAPI 3.0 and OpenAPI 3.1</figcaption></figure>
<h3 class=""><strong>Info Object</strong></h3>
<p class=""><span style="font-weight: 400;">The </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#infoObject"><span style="font-weight: 400;">Info Object in OpenAPI 3.1</span></a><span style="font-weight: 400;"> is a superset of the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#infoObject"><span style="font-weight: 400;">Info Object in OpenAPI 3.0</span></a><span style="font-weight: 400;"> having an additional </span><span style="font-weight: 400;">summary</span><span style="font-weight: 400;"> field. The APIMatic Transformer maps the Info Object’s data from OpenAPI 3.0 to OpenAPI 3.1.</span></p>
<p class=""><span style="font-weight: 400;">Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1</span></p>
<p class="mod-reset"><img class="aligncenter wp-image-1466 " src="/wp-content/uploads/2021/12/info-object-1.png" alt="Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1" width="611" height="330"></p>
&nbsp;

<figure id="attachment_1465" aria-describedby="caption-attachment-1465" style="width: 605px" class="wp-caption aligncenter"><img class="wp-image-1465 " src="/wp-content/uploads/2021/12/info-object-2.png" alt="Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1" width="605" height="265"><figcaption id="caption-attachment-1465" class="wp-caption-text">Difference between Info Objects of OpenAPI 3.0 and OpenAPI 3.1</figcaption></figure>
<h3 class=""><strong>Components Object</strong></h3>
<p class=""><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#componentsObject"><span style="font-weight: 400;">Components Object in OpenAPI 3.1</span></a><span style="font-weight: 400;"> is also a superset of the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#componentsObject"><span style="font-weight: 400;">one in OpenAPI 3.0</span></a><span style="font-weight: 400;">, which contains an additional </span><code>pathItems</code><span style="font-weight: 400;">object. However, there is a major difference between both formats in terms of </span><span style="font-weight: 400;">Schema</span> <span style="font-weight: 400;">Objects</span><span style="font-weight: 400;"> inside </span><code>Schemas</code><span style="font-weight: 400;">, </span><code>Responses</code><span style="font-weight: 400;">, </span><span style="font-weight: 400;"><code>Parameters</code>, </span><span style="font-weight: 400;">and </span><code>RequestBodies</code><span style="font-weight: 400;"> Objects.</span></p>
<p class="mod-reset">&nbsp;</p>
<p class="mod-reset">&nbsp;</p>


<figure id="attachment_1464" aria-describedby="caption-attachment-1464" style="width: 576px" class="wp-caption aligncenter"><img class="wp-image-1464 " src="/wp-content/uploads/2021/12/component-objects.png" alt="Difference between Component Objects of OpenAPI 3.0 and OpenAPI 3.1" width="576" height="345"><figcaption id="caption-attachment-1464" class="wp-caption-text">Difference between Component Objects of OpenAPI 3.0 and OpenAPI 3.1</figcaption></figure>
<h3 class=""><strong>Schema objects</strong></h3>
<p class=""><span style="font-weight: 400;">As described above, the Schema Object in OpenAPI 3.0 is an extended subset of JSON Schema Specification Wright Draft 00 </span><span style="font-weight: 400;">that made it confusing for users as some things could follow JSON schema standards while others had to be done in OpenAPI&#8217;s style.</span><span style="font-weight: 400;"> However, the Schema Object of OpenAPI 3.1 (exported from APIMatic) is a superset of JSON Schema Specification Draft 2020-12.</span></p>
<p class=""><span style="font-weight: 400;">The new JSON Schema Draft 2020-12 has some major changes with respect to the old JSON Schema Draft 00. Thus, APIMatic Transformer converts this Schema Object from old to new JSON Schema Draft while mapping OpenAPI 3.0 to OpenAPI 3.1.</span></p>
<p class=""><span style="font-weight: 400;">Mappings of some widely used components from Json Schema Draft 00 to Draft 2020-12 are explained further:&nbsp;</span></p>

<h4 class=""><strong>Nullable flag</strong></h4>
<span style="font-weight: 400;">If your OpenAPI 3.0 Schema Object contains a </span><span style="font-weight: 400;">nullable</span><span style="font-weight: 400;"> field, it will be mapped to the “</span><span style="font-weight: 400;">null</span><span style="font-weight: 400;">” type in the list of types in OpenAPI 3.1’s Schema Object since the </span><span style="font-weight: 400;">nullable</span><span style="font-weight: 400;"> field is no longer allowed in JSON Schema Draft 2020-12 and must be declared as follows:</span>
<p class=""><strong>OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody: 
  content: 
    text/plain: 
      example: 3
      schema: 
        nullable: true
        type: integer
  required: true</code></pre>
<p class=""><strong>OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        type:
        - integer
        - &#039;null&#039;
        contentEncoding: int32
        contentMediaType: text/plain
      example: 3
  required: true</code></pre>
<h4 class=""><strong>ExclusiveMinimum and ExclusiveMaximum</strong></h4>
<p class=""><span style="font-weight: 400;">In OpenAPI 3.0, </span><code>exclusiveMinimum</code><span style="font-weight: 400;"> and </span><code>exclusiveMaximum</code><span style="font-weight: 400;"> are of </span><code>Boolean</code><span style="font-weight: 400;"> type and are used in conjunction with </span><code>minimum</code><span style="font-weight: 400;"> and </span><code>maximum</code><span style="font-weight: 400;">&nbsp;respectively. However, in OpenAPI 3.1, <code>exclusiveMinimum</code> and <code>exclusiveMaximum</code> are of type </span><span style="font-weight: 400;">Number</span><span style="font-weight: 400;"> and will convey the same meaning as <code>exclusiveMinimum</code> does in conjunction with minimum or <code>exclusiveMaximum</code> with <code>maximum</code> respectively.&nbsp;</span></p>
<p class=""><strong>OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml"> requestBody: 
  content: 
    application/json: 
      schema: 
        exclusiveMaximum: true
        exclusiveMinimum: true
        maximum: 50
        minimum: 1.22
        type: number
      example: 3
  required: true</code></pre>
<p class=""><strong>OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        exclusiveMaximum: 50
        exclusiveMinimum: 1.22
        type: number
        contentEncoding: double
        contentMediaType: text/plain
      example: 3
  required: true</code></pre>
<h4 class=""><strong>Single-valued Enum and Const</strong></h4>
<p class=""><span style="font-weight: 400;">If you have a single-valued enum in your OpenAPI 3.0 file, the APIMatic Transformer maps this to a field called </span><code>const</code><span style="font-weight: 400;"> since in OpenAPI 3.1, you have the </span><span style="font-weight: 400;">const</span><span style="font-weight: 400;"> field to store the value for a single-valued enum.</span></p>
<p class=""><strong>OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody: 
  content: 
    text/plain:
      schema: 
        enum: 
          - 1
        type: integer
      example: 1
  required: true</code></pre>
<p class=""><strong>OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        const: 1
        type: integer
  required: true
</code></pre>
<h3 class=""><strong>File Upload</strong></h3>
<p class=""><span style="font-weight: 400;">In OpenAPI 3.0, you describe a file upload using </span><code>type</code> <span style="font-weight: 400;">set to <code>string</code> and </span><code>format</code> <span style="font-weight: 400;">set to <code>binary</code> or <code>base64</code> depending on how the file contents will be encoded. However, in OpenAPI 3.1, JSON Schema’s keywords </span><code>contentEncoding</code> <span style="font-weight: 400;">and </span><code>contentMediaType</code> <span style="font-weight: 400;">take care of how the contents will be encoded.&nbsp;</span></p>
<p class=""><span style="font-weight: 400;">Moreover, you don’t even need to use the Schema Object for a binary file in a POST request.</span></p>
<p class=""><strong>Binary File Upload in OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    application/octet-stream:
      schema:
        type: string
        format: binary</code></pre>
<p class=""><strong>Binary File Upload in OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    application/octet-stream: {}
</code></pre>
<p class=""><strong>Upload via Multipart Request in OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody:
content:
  multipart/form-data:
    schema:
      type: object
      properties:
        userId:
          type: integer
        fileName:
          type: string
          format: binary</code></pre>
<p class=""><strong>Upload via Multipart Request in OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    multipart/form-data:
      schema:
        type: object
        properties:
          userId:
            type: integer
          fileName:
            type: string
            contentMediaType: application/octet-stream</code></pre>
<p class=""><strong>Upload Image with base64 encoding in OpenAPI 3.0</strong></p>

<pre><code class="language-yaml">requestBody:
  content:
    image/png:
      schema:
        type: string
        format: base64</code></pre>
<p class=""><strong>Upload Image with base64 encoding in OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    image/png:
      schema:
        type: string
        format: base64</code></pre>
<h3 class=""><strong>Other Components of OpenAPI 3.0</strong></h3>
<span style="font-weight: 400;">All other components of OpenAPI 3.0 are mapped to OpenAPI 3.1 in APIMatic without any change in them.</span>
<h2 class=""><strong>Additional Changes in OpenAPI 3.1</strong></h2>
<p class="">OpenAPI 3.1 also offers additional updates like multiple examples and reference objects:</p>

<h3 class=""><strong>Multiple Examples inside Schema Object</strong></h3>
<p class=""><span style="font-weight: 400;">OpenAPI 3.0 allows multiple examples alongside Schema Object (i.e. as a sibling to Schema Object) but does not allow multiple examples inside Schema Object. Fortunately, the support for multiple examples inside Schema Object has been added in OpenAPI 3.1. But the structure of these multiple examples would be different from what we use for the examples alongside the Schema Object.</span></p>
<p class=""><span style="font-weight: 400;">Multiple examples can be defined as a list of examples as shown below, it is recommended to use examples rather than a single example in Schema Object for OpenAPI 3.1.</span></p>
<p class=""><strong>Example inside Schema Object for OpenAPI 3.0</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        type: integer
        example: 2</code></pre>
<p class=""><strong>Multiple Examples inside Schema Object for OpenAPI 3.1</strong></p>

<pre class=""><code class="language-yaml">requestBody:
  content:
    text/plain:
      schema:
        type: integer
        examples:
        - 1
        - 2
        - 3</code></pre>
<h3 class=""><strong>Reference Object</strong></h3>
<p class=""><span style="font-weight: 400;">In OpenAPI 3.1, <code>summary</code> and <code>description</code> keywords have been introduced in </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#reference-object"><span style="font-weight: 400;">Reference Object</span></a><span style="font-weight: 400;">. These <code>summary</code> and <code>description</code> fields by default should override the <code>summary</code> and <code>description</code> fields of the referenced component respectively and if the referenced component does not allow summary or description, the corresponding field will have no effect.</span></p>
<p class=""><span style="font-weight: 400;">For additional changes in OpenAPI 3.1, you can visit the </span><a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-specification"><span style="font-weight: 400;">official OpenAPI 3.1 specification</span></a><span style="font-weight: 400;">.</span></p>

<h2 class=""><strong>Transforming OpenAPI 3.0 Files to OpenAPI 3.1 via APIMatic</strong></h2>
<p class=""><span style="font-weight: 400;">APIMatic takes care of all of these mappings behind the scenes. To actually transform a file to OpenAPI 3.1, is just a matter of a few steps. We will be using a sample Customer API</span><span style="font-weight: 400;">&nbsp;in <a href="https://github.com/aliraza1231/files/blob/main/CustomerAPI.yaml">OpenAPI 3.0</a> format for this example.</span></p>

<ol class="">
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Go to the </span><a href="https://www.apimatic.io/dashboard"><span style="font-weight: 400;">APIMatic Dashboard</span></a> <span style="font-weight: 400;">and click on </span><b>Transform API</b><span style="font-weight: 400;">.</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Import the OpenAPI 3.0 specification linked above.</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Select the export format as </span><b>OpenAPI 3.1</b><span style="font-weight: 400;">.</span></li>
 	<li style="font-weight: 400;" aria-level="1"><span style="font-weight: 400;">Click on </span><b>Convert.</b></li>
</ol>
<figure id="attachment_1477" aria-describedby="caption-attachment-1477" style="width: 1920px" class="wp-caption aligncenter"><img class="size-full wp-image-1477" src="/wp-content/uploads/2021/12/apimatic-transformer-openapi3-1.gif" alt="Transforming a OpenAPI 3.0 file to OpenAPI 3.1 in APIMatic" width="1920" height="1080"><figcaption id="caption-attachment-1477" class="wp-caption-text">Transforming a OpenAPI 3.0 file to OpenAPI 3.1 in APIMatic</figcaption></figure>
<p class=""><span style="font-weight: 400;">Yay! Great, you have successfully transformed an OpenAPI 3.0 file to the latest OpenAPI 3.1 format. You can look at the </span><a href="https://github.com/aliraza1231/files/blob/main/CustomerAPI31.yaml"><span style="font-weight: 400;">exported OpenAPI v3.1 specification here</span></a><span style="font-weight: 400;">.</span></p>

<h2 class=""><strong>To Summarize</strong></h2>
<p class=""><span style="font-weight: 400;">The features and improvements offered in OpenAPI 3.1 can open many avenues for API developers in the future as more products and services will move to support OAS 3.1. APIMatic offers a quick solution with </span><a href="https://www.apimatic.io/transformer/"><span style="font-weight: 400;">API Transformer</span></a> <span style="font-weight: 400;">to convert any API definition into OpenAPI 3.1 format within seconds so you can fully utilize all tools supporting this format, and eliminate the time spent on rewriting API definitions in new formats.</span></p>

</div>
</div>
</div>
</div>						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/migrating-to-and-from-openapi-3-1/">OpenAPI 3.1 &#8211; What&#8217;s New, and How to Migrate to/from Other API Specs?</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/blog/migrating-to-and-from-openapi-3-1/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>A Year with API Transformer</title>
		<link>/blog/a-year-with-api-transformer/</link>
					<comments>/blog/a-year-with-api-transformer/#respond</comments>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 20 Apr 2018 10:53:46 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Specs]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[Open Api]]></category>
		<category><![CDATA[Usage Trends]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=592</guid>

					<description><![CDATA[<p>Developers today are actively seeking relevant tools and frameworks in order to make their API design and consumption process as easy and efficient as possible. An important part of this process is describing the API in any of the available specification formats. And since each of the API description formats come with their own toolset, [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/a-year-with-api-transformer/">A Year with API Transformer</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="592" class="elementor elementor-592">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-20b0caaf elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="20b0caaf" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-220cb7e" data-id="220cb7e" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-4c8a6d4e elementor-widget elementor-widget-text-editor" data-id="4c8a6d4e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-593 aligncenter" src="/wp-content/uploads/2021/12/1_NUcBLHXepZNfgEswFi9UzA.jpg" alt="A Year with API Transformer 2017" width="1000" height="400"></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="15dd" class="">Developers today are actively seeking relevant tools and frameworks in order to make their API design and consumption process as easy and efficient as possible. An important part of this process is describing the API in any of the available specification formats. And since each of the API description formats come with their own toolset, the need to be able to convert between different formats is growing rapidly. This is where <a href="https://www.apimatic.io/transformer">API Transformer</a> comes into play. It offers a tool called “<strong>Convertron</strong>” which has helped many users transform their API description files from one format to another. Many popular formats like&nbsp;<a href="https://swagger.io/specification/">OpenAPI</a>, <a href="https://raml.org/">RAML</a>, etc. are supported.</p>
<p id="3fb9" class="">Over the years, API Transformer has evolved quite a lot. In particular, the year 2017 saw some important additions to the tool like the <a href="https://apimatic.io/blog/2017/05/apimatic-turns-3-announcing-support-of-oas-3-0">newly added support for OpenAPI 3</a>&nbsp; and WSDL. Many improvements were also made to the existing format parsers in which, without any doubt, the valuable feedback from our amazing users played a vital role. The year has flown away but has left behind some interesting trends and patterns that we plan to share with you today in this blog.</p>
<h2 id="38fc" class="">Trends from 2017</h2>
<p id="076a" class="">For each aspect, two kinds of data will be analyzed. One will take into account all events that occurred irrespective of the users performing these events. However, we have a handful of users who perform thousands of conversions every month. The first data gets largely skewed because of these conversions. So in the second data, to get a better picture, we try to remove this skewed behavior of the data by considering only unique events per user.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_594" aria-describedby="caption-attachment-594" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-594" src="/wp-content/uploads/2021/12/1_nPsR6Mra5k2662q79wtUKA-1024x268.png" alt="Transformer Usage 2017" width="1024" height="268"><figcaption id="caption-attachment-594" class="wp-caption-text">Transformer Usage 2017</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class="has-text-align-center"><strong>Most Common Formats Brought In By Developers</strong></p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_597" aria-describedby="caption-attachment-597" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-597" src="/wp-content/uploads/2021/12/1_hgXyTyoyGGuFaIdl79_UsA-2-1024x498.png" alt="Total vs Unique Analysis of Most Common Formats Imported" width="1024" height="498"><figcaption id="caption-attachment-597" class="wp-caption-text">Total vs Unique Analysis of Most Common Formats Imported</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="3b19" class="">Out of the total imported files on Transformer (approximately 94,000), 50% were Postman 1.0 files, 25% were Postman 2.X while only 6% were OpenAPI 2.0. The second graph does not consider redundant format conversions per user e.g. if a user converted fifty Postman 1.0 and ten OpenAPI 2.0 files, he converted two unique format files (one Postman and one OpenAPI). Elimination of this redundancy shows that 24% of the imported files were defined using OpenAPI 2.0, 20% were using Postman 2.X while 10% were using WSDL. The rest falls in the smaller chunks. So the most common formats brought in by developers were&nbsp;<strong>OpenAPI</strong>&nbsp;and&nbsp;<strong>Postman</strong>.</p>
<h2 id="239f" class=""><strong>Most Common Formats Developers Loved Exporting To</strong></h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_598" aria-describedby="caption-attachment-598" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-598" src="/wp-content/uploads/2021/12/1_ZxiFUSv6zuu6dZbmD4xGWQ-1024x511.png" alt="Total vs Unique Anaylsis of Most Common Formats Exported" width="1024" height="511"><figcaption id="caption-attachment-598" class="wp-caption-text">Total vs Unique Analysis of Most Common Formats Exported</figcaption></figure>
</figure>
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="49b5" class="">52% of the API description files were exported to API Blueprint while 35% to OpenAPI 2.0. Eliminating multiple exports to the same format per user, we observed that 55.5% of the files were exported to OpenAPI 2.0 while 9% to RAML 1.0. API Blueprint was not very dominant in this second case. Overall,&nbsp;<strong>OpenAPI 2.0</strong>&nbsp;seemed to take the lead for the format that developers wanted to play around with.</p>
<p id="49b5" class="">The choice of the format when exporting could have been related to several factors like size of the community, tools, and frameworks available, strong documentation, and availability of a newer and stable version with more features, to name a few. OpenAPI 2.0 and Postman 2.0/2.1 are a natural preference over their older versions (OpenAPI 1.2, Postman 1.0). Very few users prefer to export to WADL or WSDL because of limited usage and tooling.</p>
<h2 id="8dfa">Most Common Format Conversions</h2>
</div>
</div>
</div>
</div>
<!-- /wp:image -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_600" aria-describedby="caption-attachment-600" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-600" src="/wp-content/uploads/2021/12/1_ZQQsPA96_vXC2uzHXHdzUA-1-1024x383.png" alt="Total vs Unique Analysis of Top Ten Format Conversions" width="1024" height="383"><figcaption id="caption-attachment-600" class="wp-caption-text">Total vs Unique Analysis of Top Ten Format Conversions</figcaption></figure>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="fe70" class="">We also looked at the top ten import-export mappings to understand which conversions are most popular. For the total conversions performed, the most common conversion seen was from Postman 1.0 to API Blueprint (approx 45,000 conversions) whereas if we eliminate non-unique mappings per user, import from&nbsp;<strong><em>Postman 2.X to OpenAPI 2.0</em></strong>&nbsp;was found to be the most common (approx 530). This shows that a lot of developers prefer Transformer for converting&nbsp;<strong>from Postman to other API description formats</strong>.</p>
<h2 id="4312">Geographical Usage of Formats</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_601" aria-describedby="caption-attachment-601" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-601" src="/wp-content/uploads/2021/12/1_WP6Umd8XIusdVoxazoqtQw-1024x352.png" alt="Total vs Unique Analysis of Geographical Usage of Formats" width="1024" height="352"><figcaption id="caption-attachment-601" class="wp-caption-text">Total vs Unique Analysis of Geographical Usage of Formats</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="e7b3" class="">From the above graphs, you can see that users of Transformer are distributed far and wide into various geographical regions of the world. We had some users performing thousands of conversions every month from India and they constitute 52% of the total conversions represented in the first case. If multiple conversions from the same location per user are ignored, we see that 24% of the conversions occurred from the US while only 10% were performed from India. Hence, the majority of our users using Transformer in 2017 were based in the <strong>US and India.</strong></p>
<p id="019a">Note that for these graphs we eliminated data of conversions in which the locations were unknown.</p>
<h2 id="5dee" class="">Most Common Formats That Failed To Transform</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_602" aria-describedby="caption-attachment-602" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-602" src="/wp-content/uploads/2021/12/1_KOksY86ZTLjamtrzlxjHrw-1024x515.png" alt="Total vs Unique Analysis of Most Common Format Failures" width="1024" height="515"><figcaption id="caption-attachment-602" class="wp-caption-text">Total vs Unique Analysis of Most Common Format Failures</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="d223" class="">Some of the users failed to transform their files (approx 8,000 which is roughly 8% of the total conversions performed). 35% of the total failed conversions were invalid/unsupported (more on this later) while 30% were RAML files (0.8/1.0) and 18% were OpenAPI files (1.X/2.0). By removing redundant failures of the same format per user, a big 44% of the chunk of failures belonged to the invalid/unsupported, 20% belonged to RAML(0.8/1.0) while 17% were OpenAPI files (1.X/2.0).</p>
<p id="2370" class="">As you can see, a large portion of failures constitutes of the&nbsp;<strong>invalid/unsupported files</strong>. These were the files which were either:</p>
<ul class="">
<li id="4bfe">Not valid API description files e.g. HTML files, JSON response data, XML schema files OR</li>
<li id="3c2a">Supported by Transformer but lacked necessary metadata that prevented proper identification e.g. API Blueprint files without “Format” and “Host” information. Some common mistakes also prevented proper identification of the files (invalid JSON, incomplete file, etc.) OR</li>
<li id="3663">Not supported by Transformer in 2017 e.g. Insomnia</li>
</ul>
<p id="aba8" class="">The rest of the conversions are largely attributed to&nbsp;<strong>RAML or OpenAPI</strong>&nbsp;files. A common cause for these is uploading a file containing external references without providing these references within the specification file.</p>
<h2 id="8308">Transformations via Web vs Transformations via API</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_603" aria-describedby="caption-attachment-603" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-603" src="/wp-content/uploads/2021/12/1_WpsbcgB_75hO87-D9AXkMA-1024x438.png" alt="Total vs Unique Comparison of Transformer Web and API Conversions" width="1024" height="438"><figcaption id="caption-attachment-603" class="wp-caption-text">Total vs Unique Comparison of Transformer Web and API Conversions</figcaption></figure>
<figcaption></figcaption>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="9192" class="">API Transformer not only provides a web UI to users for performing conversions but also facilitates them by providing a simple API that offers the same functionality as the UI. In 2017, 76% of the total conversions were made using the API. However, by considering only unique web/API conversions per user shows that&nbsp;<strong>96% of the conversions were made using the web interface</strong>.</p>
<h2 id="99c8">Size of the APIs</h2>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<figure id="attachment_604" aria-describedby="caption-attachment-604" style="width: 718px" class="wp-caption aligncenter"><img class="wp-image-604" src="/wp-content/uploads/2021/12/1_TiawMyqOHqW0zjam3qmnfQ.png" alt="Analysis of Size of API for Total Conversions" width="718" height="445"><figcaption id="caption-attachment-604" class="wp-caption-text">Analysis of Size of API for Total Conversions</figcaption></figure>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="e1ee" class="">For measuring the size of an API, we considered the number of endpoints in an API. Pretty much all the APIs had less than 300 endpoints. However, a very small portion (0.39% of the total conversions and 2.61% of the unique conversions per user) of large APIs also existed that had endpoints ranging above 300.</p>
<h2 id="e9bd">Conclusion</h2>
<p id="5fe9" class="">2017 was no doubt an exciting year offering intriguing insights into<a href="https://www.apimatic.io/transformer"> API Transformer</a>. This year we plan to make Transformer even better by adding other commonly used formats like&nbsp;&nbsp;Insomnia and by improving other areas of it as well. So, stay tuned!</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/a-year-with-api-transformer/">A Year with API Transformer</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/blog/a-year-with-api-transformer/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Common Mistakes Developers Make In Their OpenAPI 3 Files</title>
		<link>/blog/common-mistakes-developers-make-in-their-openapi-3-files/</link>
					<comments>/blog/common-mistakes-developers-make-in-their-openapi-3-files/#respond</comments>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 09 Mar 2018 10:53:46 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Specs]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[Developers]]></category>
		<category><![CDATA[Open Api]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=561</guid>

					<description><![CDATA[<p>OpenAPI 3 (OAS 3) is the latest iteration of the OpenAPI Specification.&#160;APIMatic has been supporting the format since it was still a release candidate. With adoption rates for OAS 3 going up, we noticed a few common mistakes developers are prone to make. Majority of these relate to the way certain features worked with OAS [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/common-mistakes-developers-make-in-their-openapi-3-files/">Common Mistakes Developers Make In Their OpenAPI 3 Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="561" class="elementor elementor-561">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-4cc673ec elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="4cc673ec" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-5e480934" data-id="5e480934" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-4b49bdc8 elementor-widget elementor-widget-text-editor" data-id="4b49bdc8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class="">OpenAPI 3 (OAS 3) is the latest iteration of the OpenAPI Specification.&nbsp;<a href="https://apimatic.io/blog/2017/05/apimatic-turns-3-announcing-support-of-oas-3-0">APIMatic has been supporting the format</a> since it was still a release candidate. With adoption rates for OAS 3 going up, we noticed a few common mistakes developers are prone to make. Majority of these relate to the way certain features worked with OAS 2.0 (more commonly known as Swagger 2.0) but require a different approach with OAS 3.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_562" aria-describedby="caption-attachment-562" style="width: 978px" class="wp-caption aligncenter"><img class="wp-image-562" src="/wp-content/uploads/2021/12/1_8gRmupEoR2NxC_uwstwhSw.png" alt="Common Mistakes Developers Make In Their OpenAPI 3 Files" width="978" height="490"><figcaption id="caption-attachment-562" class="wp-caption-text">Mistakes Found In OAS 3 Files During Conversions On&nbsp;API Transformer</figcaption></figure>
</figure>
<!-- /wp:image -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="284d" class="">Using the old “<code>swagger”</code>&nbsp;property to specify OpenAPI version</h2>
<p id="2472" class="">A Swagger user, who has had his hands dirty with version 2.0, would usually specify Swagger version using the&nbsp;<code>swagger</code>&nbsp;property as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-json">{
  &quot;swagger&quot;: &quot;2.0&quot;
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="029b" class="">When migrating towards OAS 3, developers are still seen using the same property to specify the version of the newer format.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-json">{
  &quot;swagger&quot;: &quot;3.0.0&quot;
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="660f" class="">This is&nbsp;<strong>invalid</strong>&nbsp;as OAS 3 has now replaced that with the new&nbsp;<code>openapi</code>&nbsp;<a href="https://swagger.io/specification/#openapi-object-17">property</a> which makes use of semantic versioning.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-json">{
  &quot;openapi&quot;: &quot;3.0.0&quot;
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="7892" class="">Defining body parameter in the “parameters”</h2>
<p id="bd42" class="">Remember how Swagger 2.0 let you define a&nbsp;<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#parameter-object">body parameter</a>&nbsp;in the operation&nbsp;<code>parameters</code>&nbsp;using location set to&nbsp;<code>body</code>? Compared to parameters located elsewhere (query, header, path, formData), this parameter had less restrictions and used a schema object for type definition. OAS 3 decided to separate this parameter for good and let it have its own place in&nbsp;<code>requestBody</code>. The form parameters are also covered under this new property. But developers are still bent on defining the body parameter in the&nbsp;<code>parameters</code>&nbsp;section.&nbsp;<em>Sigh.</em><br><br>This is now&nbsp;<strong>invalid</strong>&nbsp;in OAS 3:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;parameters&quot;: [
 {
   &quot;name&quot;: &quot;body&quot;,
   &quot;in&quot;: &quot;body&quot;,
    &quot;schema&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
 },
 {
   &quot;name&quot;: &quot;petId&quot;,
   &quot;in&quot;: &quot;path&quot;,
   &quot;schema&quot;: {
      &quot;type&quot;: &quot;string&quot;
   }
 }]</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="9d4f">The correct way is to instead use&nbsp;<code>requestBody</code>&nbsp;for form and body parameters:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;parameters&quot;: [
 {
   &quot;name&quot;: &quot;petId&quot;,
   &quot;in&quot;: &quot;path&quot;,
   &quot;schema&quot;: {
     &quot;type&quot;: &quot;string&quot;
   }
 }],
&quot;requestBody&quot;:{
&quot;content&quot;: {
  &quot;text/plain&quot;: {
    &quot;schema&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
   }
 }
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="7b70" class="">Declaring response headers as a list of Header objects</h2>
<p id="8535" class="">It looks like some developers are trying to generate their OAS 3 files from 3rd party tools that do not fully conform to the OAS standards. This results in inaccurate header objects. The&nbsp;<a href="https://swagger.io/specification/#response-object-71">specification</a>&nbsp;states that the response headers must be:</p>
<p id="9f02">1) A map with header name as key and Header object as value&nbsp;<strong>OR</strong></p>
<p id="5da3" class="">2) A map with header name as key and a Reference object as value (that basically would still point to a Header object).</p>
<p id="a288" class="">This implies that an array of header objects or an array of reference header objects can, therefore, not be used but the mistake is still seen quite commonly. Also, the Swagger editor itself does not seem to complain in either case.</p>
<p id="313a">So essentially this is&nbsp;<strong>invalid</strong>&nbsp;(at least as per the spec):</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;responses&quot;: {
   &quot;200&quot;: {
      &quot;description&quot;: &quot;Response for content that consists of a single part.&quot;,
       &quot;headers&quot;: [
       {
         &quot;$ref&quot;: &quot;#/components/headers/HeaderName&quot;
       }]
   }
}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>The valid way is to use a map instead:</p>
<pre class=""><code class="language-json">&quot;responses&quot;: {
   &quot;200&quot;: {
      &quot;description&quot;: &quot;Response for content that consists of a single part.&quot;,
     &quot;headers&quot;: {
       &quot;HeaderName&quot;: {
          &quot;$ref&quot;: &quot;#/components/headers/HeaderName&quot;
        }
     }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="e448">Referencing an undefined OAS 3 component</h2>
<p id="f657" class="">Last but not the least, developers often reference an OAS 3 component (definition of a schema, parameter, response, header or a security scheme, etc.) but they don’t define this component in the relevant section of the root <code>components</code>&nbsp;<a href="https://swagger.io/specification/#componentsObject">object</a>. So for example, an OAS 3 response in the API file may be referencing a schema definition like:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">&quot;responses&quot;: {
   &quot;200&quot;: { 
      &quot;content&quot;: {
         &quot;application/json&quot;: {
           &quot;schema&quot;: {
             &quot;$ref&quot;: &quot;#/components/schemas/pet&quot; 
           }
         }
      }
    }
 }</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p>This requires a definition for&nbsp;<code>pet</code>&nbsp;to be present under the&nbsp;<code>schemas</code>&nbsp;property that itself would lie inside the root&nbsp;<code>components</code><a href="https://swagger.io/specification/#componentsObject">property</a> as follows:</p>
<pre class=""><code class="language-json">&quot;components&quot;: {
   &quot;schemas&quot;: {
      &quot;pet&quot;: {
         &quot;type&quot;: &quot;object&quot;,
         &quot;properties&quot;: {
           &quot;propertyName&quot;: {
              &quot;type&quot;: &quot;string&quot;
            }
          }
       }
    }
}</code></pre>
<p id="3c66" class="">A lot of users forget to define some of these referenced components. Do ensure that any such references you make to components using <code>$ref</code> are resolvable to avoid issues with tools that use this format.</p>
</div>
</div>
</div>
</div>
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="ca92" class="">Conclusion</h2>
<p id="d0ea" class="">As of date, there is no official JSON schema available for OAS 3. With the release of JSON schema, we can expect better validation of OAS 3 files, which will ultimately lead to OAS 3 tools and services becoming more stable and consistent. It’s only then that the probability of such mistakes occurring will decline.</p>
<p id="a6b7" class="">Have OAS files of your own? Head over to&nbsp;<a href="https://www.apimatic.io/transformer">Transformer</a> and start converting to other formats.&nbsp;</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/common-mistakes-developers-make-in-their-openapi-3-files/">Common Mistakes Developers Make In Their OpenAPI 3 Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/blog/common-mistakes-developers-make-in-their-openapi-3-files/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
