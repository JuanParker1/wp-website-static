
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Raml Archives - APIMatic</title>
	<atom:link href="/blog/tag/raml/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>APIMatic is an API documentation tool that provides a complete set of DX components such as autogenerated SDKs, API portal, API docs, live code samples, and more.</description>
	<lastBuildDate>Mon, 11 Apr 2022 05:37:11 +0000</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>

<image>
	<url>/wp-content/uploads/2021/10/cropped-cropped-apimaticio-favicon-1-32x32.png</url>
	<title>Raml Archives - APIMatic</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>6 Practices to Achieve Consistency across API Specifications</title>
		<link>/blog/6-practices-to-achieve-consistency-across-api-specifications/</link>
		
		<dc:creator><![CDATA[APIMatic]]></dc:creator>
		<pubDate>Fri, 20 Sep 2019 11:02:52 +0000</pubDate>
				<category><![CDATA[API Documentation]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Api Design]]></category>
		<category><![CDATA[Open Api]]></category>
		<category><![CDATA[Raml]]></category>
		<category><![CDATA[Swagger]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=666</guid>

					<description><![CDATA[<p>This blog is based on a talk presented at APIMatic’s meet-up&#160;&#160;in San Francisco earlier in the year.&#160; API specifications have become a crucial part of the API life cycle, acting as a gateway to better design, documentation and tooling for your API. Due to the growing popularity of API specifications, more and more organizations are [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/6-practices-to-achieve-consistency-across-api-specifications/">6 Practices to Achieve Consistency across API Specifications</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="666" class="elementor elementor-666">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-e60d326 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="e60d326" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1fa8c7cd" data-id="1fa8c7cd" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-2d4278a2 elementor-widget elementor-widget-text-editor" data-id="2d4278a2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
			<style>/*! elementor - v3.6.4 - 13-04-2022 */
.elementor-widget-text-editor.elementor-drop-cap-view-stacked .elementor-drop-cap{background-color:#818a91;color:#fff}.elementor-widget-text-editor.elementor-drop-cap-view-framed .elementor-drop-cap{color:#818a91;border:3px solid;background-color:transparent}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap{margin-top:8px}.elementor-widget-text-editor:not(.elementor-drop-cap-view-default) .elementor-drop-cap-letter{width:1em;height:1em}.elementor-widget-text-editor .elementor-drop-cap{float:left;text-align:center;line-height:1;font-size:50px}.elementor-widget-text-editor .elementor-drop-cap-letter{display:inline-block}</style>				<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-667 aligncenter" src="/wp-content/uploads/2021/12/1_BYxuxcs43uZuq_Dwuti2ZQ-1024x512.jpg" alt="6 Practices to Achieve Consistency across API Specifications" width="1024" height="512"></p>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<blockquote>
<p class="">This blog is based on a talk presented at APIMatic’s <a href="https://youtu.be/hBDDc_qhnU4">meet-up&nbsp;&nbsp;in San Francisco</a> earlier in the year.&nbsp;</p>
</blockquote>
<p id="fe62" class="">API specifications have become a crucial part of the API life cycle, acting as a gateway to better design, documentation and tooling for your API.</p>
<p id="5660" class="">Due to the growing popularity of API specifications, more and more organizations are moving towards spec-driven development. In this process, API are designed before built, so that any flaws and inconsistencies are recognized early on and fixed before the development. The approach ensures you stay on budget and avoid snags that can come from miscommunication.</p>
<p id="e125" class="">While a spec may ensure that there are no hiccups while developing APIs, the document itself is prone to inconsistencies and errors. Multiple stakeholders including developers, product owners, and technical writers contribute to the spec, and with all of them bringing in their own flavor and style, it often ends up looking like a mess.</p>
<p id="6a58" class="">Moreover, a spec is more than just a design artifact, it serves as a gateway to various API tooling throughout the API lifecycle. Many of the API Design, Management, Testing, Deployment, and Documentation tools today take API Specifications as input to work on the API, and unless free of flaws and contradictions, a spec can never be rendered in an efficient or effective manner.</p>
<p id="e314" class="">It’s therefore essential to have a set of guidelines to ensure the document remains free of conflicting styles and formats and is produced in one cohesive manner. This blog will cover a few of these guidelines and practices that you can follow to achieve consistency across the API Specification workflow while keeping it functional and agile.</p>
<h2 id="358a"><strong>1. Create a Style Guide</strong></h2>
<p id="8a35">Often organisations have a style guide for designers and writers to follow when producing branding content and material. In a similar fashion, all API teams should develop a style guide for writing API Specifications. And it should be enforced as a uniform practise throughout the organisation. The guide should recommend what sort of conventions and practices are to be used when contributing to the specification.</p>
<p id="e581" class="">For instance, often it’s unclear if:</p>
<ul class="">
<li>Schemas should have examples</li>
<li>In-line schemas are permissible</li>
<li>Operations must have descriptions</li>
<li>Parameters and responses restricted to certain types or numbers</li>
</ul>
<p id="8cdd" class="">Similarly, in many more cases like that, contributors whenever in doubt, just work with a style they are used to or comfortable with. The easy way out is to standardize these practices, and recommend a way which guides contributors from all departments to make additions in a uniform manner.</p>
<p id="35a2" class="">To ensure that the recommended practices are being followed, and no conflicts make through to the actual document, validators should be set up that verify if the addition is aligned with the recommended style. This can be executed with Linters, a popular linting tool for specs is “<a href="https://github.com/wework/speccy">Speccy</a>”, which takes your custom rules and runs the specs against it, validating it against those rules.</p>
<p id="c2bc" class="">Building validation into the CI/CD cycle further streamlines the process, so whenever updates are pushed to your API, they first go through these checks so that nothing of varying nature is added to your specification.</p>
<h2 id="4a8c"><strong>2. Promote Visibility and Reusability</strong></h2>
<p id="26b6" class="">Another common practice and really a nice one is to publish your API specs to Version Control for across board visibility. Make them available on a master repository and create a pull request mechanism, allowing nothing to pass to the central repository without a review, while still allowing contributors to view and make use of each and every contribution.</p>
<p id="9d76" class="">A big part of the specification is the schema itself, many organizations today are using JSON schema to define those specifications, even though OpenAPI has a schema that is subset of JSON schema, but JSON schema has very good tooling around it and in many more numbers. Defining models in JSON schema would make the spec very versatile and open-ended.</p>
<p id="892e" class="">You can again use Speccy to convert JSON schema to OAS schemas. This would allow you two things:</p>
<ul class="">
<li><strong>Keeping your schema separate from API specifications</strong></li>
</ul>
<p id="f7de">You have a new team and they want to use the same object the other team is using, from going to actually write it from hand again, and having discrepancies, you can use the same schema, just refer it in your spec.</p>
<ul class="">
<li><strong>Validating API specifications</strong></li>
</ul>
<p id="725f" class="">With JSON Schema Linting, you can write better tests. Resulting in better validation of schema.</p>
<p id="4ffb" class="">And for every artifact you are creating, schema or the spec, version them, so once your program scales, you know what version your API team is dependent on.</p>
<h2 id="5493"><strong>3. Separate API Design from Documentation</strong></h2>
<p id="f93c" class="">A specification is normally maintained by API developers, they are the people responsible for putting in what the requests are, what the endpoints are, how the responses would look like, basically the people turning an API into reality, but there is also a team of tech writers who work on the spec to add documentation, sample code, guides and tutorials, and all sort of help material to make sure that the API human-readable and usable.</p>
<p id="350e">To allow both the development and documentation team to work simultaneously, you can maintain documentation and tutorials as a separate project while the developers work on the spec to make changes to design</p>
<p id="6948" class="">There’s a concept of&nbsp;<strong>overlays</strong>, which has already been introduced in RAML and is still being talked about in OpenAPI Spec, and we here at APIMatic are actually building this out in our own format. What Overlays essential does is allow separation of these two concerns, letting your tech writers work independently so that any drastic change made to the specification does not affect them. The two can be merged later to make a comprehensive API reference.</p>
<h2 id="1af4" class=""><strong>4. Tag your Operations</strong></h2>
<p id="9fdc" class="">Another great practice is tagging your operations with groups and status and creating multiple versions of the same spec, for instance: Dev, Public, Partner, and Internal for different stakeholders. With this, a team can work on the same spec without creating multiple versions, and expose only the portions of that spec to the people they want it to be exposed. While exposing an Internal API, out of many hundreds of endpoints, choose the ones you want to make public while keeping the original spec as a single source of truth.</p>
<h2 id="8cbb" class=""><strong>5. Merge your API Specifications</strong></h2>
<p id="a227" class="">As your API team expands, you have multiple teams working on different services, the recommended practice is that specs for those services are maintained independently. Developers working on those services, as soon as they are done the building, update the spec and get it out. However, maintaining these services and specs separately does not mean they have to be exposed to the user in a similar fashion. Merging these different specs into a single unified one can provide the advantage of presenting a single view, single documentation, single library, and a single mock service.</p>
<p id="6a5c" class="">Few specification formats, especially the OpenAPI format is flexible enough to achieve this and anybody get a pipeline running by just writing a script. But the tool that we are working on at APIMatic will be able to merge any specification into a single one regardless of the format and the nature of it.</p>
<h2 id="8879" class=""><strong>6.</strong> Generate<strong> Changelogs</strong></h2>
<p id="b808" class="">This is another form of validation that you can achieve before making your specification public. Let’s say a developer comes in and makes an optional parameter, required. Now that would make things different for the user, and would not want this released without a version bump or release notes.</p>
<p id="bdb6" class=""><a href="https://github.com/Sayi/swagger-diff">Swaggerdiff</a>&nbsp;is a tool that can help you avoid that. Although it can work with just OpenAPI formats, for now, you can always make use of API Transformer to convert your spec to the format it supports and then run rests for your specifications to detect breaking and minor changes, which can be rendered in form of change-logs. A little work by your documentation team and they’d be good to go for your audiences as well.</p>
<h2 id="cee6" class="">What’s Next?</h2>
<p id="ca0a" class="">Now that you know what practices you need to follow to make sure the Spec is produced in a neat, clean and well-organized manner, it’s now time to consider the big question. What can you do with that spec, or why do you need such a well-rounded spec in the first place? Stay tuned for the next blog in line, which will discuss what can be done with a great-looking API specification.</p>
</div>
</div>
</div>
</div>
<!-- /wp:embed -->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/6-practices-to-achieve-consistency-across-api-specifications/">6 Practices to Achieve Consistency across API Specifications</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Common Mistakes Developers Make In Their RAML Files</title>
		<link>/blog/common-mistakes-developers-make-in-their-raml-files/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 27 Apr 2018 10:53:45 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[API]]></category>
		<category><![CDATA[Apimatic]]></category>
		<category><![CDATA[Mistakes]]></category>
		<category><![CDATA[Raml]]></category>
		<category><![CDATA[Transformer]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=550</guid>

					<description><![CDATA[<p>RESTful API Modeling Language more commonly known as&#160;RAML&#160;has been around for quite some time now (more than 4 years). As its name suggests, it is an API Modeling language used by plenty of developers to design their APIs from scratch. It offers features like reusable libraries, traits, etc. that are not yet available in other [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/common-mistakes-developers-make-in-their-raml-files/">Common Mistakes Developers Make In Their RAML Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="550" class="elementor elementor-550">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-6cc6a963 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="6cc6a963" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-7f2ea21" data-id="7f2ea21" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-6a0ad729 elementor-widget elementor-widget-text-editor" data-id="6a0ad729" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:image -->
<figure class="wp-block-image size-large">
<figure id="attachment_551" aria-describedby="caption-attachment-551" style="width: 1024px" class="wp-caption aligncenter"><img class="wp-image-551" src="/wp-content/uploads/2021/12/1_xbbRC6Sv2SPhl_EwAXoxJQ-1024x389.png" alt="Commonly Observed Mistakes Developers Make When Converting RAML Files on Transformer" width="1024" height="389"><figcaption id="caption-attachment-551" class="wp-caption-text">Commonly Observed Mistakes Developers Make When Converting RAML Files on Transformer</figcaption></figure>
</figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="228c" class="">RESTful API Modeling Language more commonly known as&nbsp;<a href="http://raml.org/">RAML</a>&nbsp;has been around for quite some time now (more than 4 years). As its name suggests, it is an API Modeling language used by plenty of developers to design their APIs from scratch. It offers features like reusable libraries, traits, etc. that are not yet available in other popular API description formats.</p>
<p id="4d7a" class="">In this blog, I will highlight some of the frequently seen mistakes in RAML files (for both versions <code>0.8</code>&nbsp;and&nbsp;<code>1.0</code>). If you have read my previous blog about the <a href="https://apimatic.io/blog/2018/03/common-mistakes-developers-make-in-their-openapi-3-files">common mistakes developers make in their OpenAPI 3 files</a>, you may notice some similarities which is to do with the fact that these API description formats, although serving their own distinct purposes, have a lot in common.</p>
<h2 id="282f" class="">Trying to Reference Components That Don’t Exist</h2>
<p id="ebb0" class="">The biggest portion of the RAML failures associated with developer mistakes are ones in which certain components are referenced but these references fail to get resolved. Common causes are discussed below:</p>
<h3 id="ba79" class=""><strong>Externally referenced files not provided</strong></h3>
<p id="2fc1" class="">RAML allows developers to split their API description file into multiple files and reference the components across these files using the&nbsp;<code>!include</code>&nbsp;tag. Depending on the size of the API, a RAML file is usually split into a large number of files e.g. a main RAML file, schema files, schema JSON example files, etc.</p>
<p id="871c" class="">Plenty of developers upload only their main RAML file but do not provide the other referenced files. In general, a ZIP is required or a base URL from which relative files can be loaded. Sometimes even when these are provided, the failures can still occur if there are files referenced that are not present in the uploaded ZIP file or could not be loaded relatively from the URL. Our Transformer tool performs validation of URLs/ZIP files to help indicate any such missing files. Keep an eye out on the warnings when performing your conversion to avoid failures due to missing files.</p>
<h3 id="8c17" class="">Incorrect paths/Invalid file names</h3>
<p id="760b" class="">Some common scenarios observed where developers face conversion failures in such cases is when:</p>
<ul class="">
<li>The file they are trying to reference (e.g.&nbsp;<code>IAmAFile.raml</code>) exists with a different name (e.g.&nbsp;<code>IAmAFile_Version2.raml</code>).</li>
<li>The file exists in a different directory (e.g.&nbsp;<code>Directory1/IAmAFile.raml</code>) to the one in which they are trying to locate the file (e.g.&nbsp;<code>Directory2/IAmAFile.raml</code>).</li>
<li>The file path is a URL like&nbsp;<a href="http://example.com/files/IAmAFile.raml">http://example.com/files/IAmAFile.raml</a>&nbsp;but the URL is either broken/not publicly accessible.</li>
</ul>
<h3 id="ecd4" class=""><strong>RAML components (Types, Resource Types, Traits, etc.) referenced but not defined</strong></h3>
<p id="90a9" class="">As discussed previously, RAML processing generally involves plenty of files. Developers bring in files that reference a component (like a type definition, resource type or a trait) in another file (e.g. a library) but the component is not defined in that file. It is possible that the component exists with a slightly different name or is located in some other file. This issue can occur in a single-file RAML as well.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-yaml">#%RAML 1.0
title: Hello world
mediaType: application/json
/helloworld:
  post:
    body:
      type: HelloMessage</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="0cc6" class="">In the above example, the request body of the&nbsp;<code>POST</code>&nbsp;method references type&nbsp;<code>HelloMessage</code>&nbsp;but this type is not declared anywhere. Since it is not a RAML primitive type, it MUST be declared under the&nbsp;<code>types</code>&nbsp;section as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">#%RAML 1.0
title: Hello world
mediaType: application/json
types:
  HelloMessage:
/helloworld:
  post:
    body:
      type: HelloMessage</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="bb94" class="">Similarly, if a library type is referenced the developer needs to ensure that the definition for the type resides in that library.</p>
<h3 id="7849">You can’t reference a RAML type in a JSON Schema</h3>
<p id="19a2" class="">A very interesting mistake noted in RAML&nbsp;<code>1.0</code>&nbsp;files was that several developers try referencing RAML types from within a JSON schema definition e.g. in the following example the body schema contains a property&nbsp;<code>input</code>&nbsp;that tries referencing a RAML type&nbsp;<code>HelloMessage</code>(defined using RAML&nbsp;<code>types</code>&nbsp;component).</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">#%RAML 1.0
title: Hello world
mediaType: application/json
types:
  HelloMessage:
    properties:
      message: string
/helloworld:
  post:
    body:
      type: |
      {
        &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema&quot;,
        &quot;properties&quot;: {
          &quot;input&quot;: {
            &quot;type&quot;: &quot;HelloMessage&quot;
           }
         },
        &quot;type&quot;: &quot;object&quot;
       }</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="86ae" class="">This is invalid as a JSON schema definition is completely independent of the RAML specification and any types that need to be used must be defined in the root <code>definitions</code>&nbsp;of the schema itself.</p>
<h2 id="3cda">Invalid YAML Means Invalid RAML</h2>
<p id="9a50">RAML uses YAML as its underlying format. So a RAML file has to abide by the rules set by both YAML and RAML specifications. A large number of developers upload files with invalid YAML content. Some of the common causes are discussed below.</p>
<h3 id="027c">Using tab spacing which is not allowed</h3>
<p id="30f4" class="">That is correct. YAML does not allow tabs but a lot of developers still use it for the indentation of their RAML files.</p>
<h3 id="0c3b" class="">Treating YAML as case-insensitive</h3>
<p id="4455" class="">YAML is case-sensitive. Developers try referencing types named like&nbsp;<code>IAmAType</code>&nbsp;as&nbsp;<code>iamatype</code>&nbsp;which is invalid as they both are different.</p>
<h3 id="2d6c">Missing space between property key and value</h3>
<p id="d200">When defining a property, YAML requires that there be a space between the property key and the value. Developers still try and define the property like:</p>
<p id="358b"><code>property1:propertyValue</code></p>
<p id="2685">This is invalid as the correct way is:</p>
<p id="0090"><code>property1: propertyValue</code></p>
<h3 id="4ebf">Improper nesting</h3>
<p id="3243">Every nested item must be indented with two spaces inside the parent one e.g. a property property2 nested inside property1 must be declared as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>property1:
  property2:</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="9042" class="">This is not followed by most of the developers.</p>
<h3 id="1efc">Unescaped strings</h3>
<p id="1be1">A lot of developers forget to escape strings that contain reserved characters e.g. the following is invalid as the description field containing the reserved character&nbsp;<code>:</code>&nbsp;is not escaped properly.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-yaml">/helloworld:
  post:
    body:
      description: Testing: 123</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="7771">The description must be escaped using quotes as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">/helloworld:
  post:
    body:
      description: &#039;Testing: 123&#039;</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="ddcd">Incorrect Usage of RAML Libraries</h2>
<p id="b07d" class="">RAML introduced its users to libraries in version&nbsp;<code>1.0</code>. Developers make certain mistakes when applying these libraries.</p>
<h3 id="9df1">Declaring library content inline</h3>
<p id="ffc2" class="">A library must be defined in a RAML fragment file which is separate from the files that will reference it. The file referencing it (a master RAML file or some other fragment file) must use the&nbsp;<code>uses</code>&nbsp;property to specify a name and path to the library as shown below:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-yaml">uses:
  file-type: file-type.raml</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="674d" class="">However, it is seen that a lot of developers try and define the library inline where otherwise a library path is expected:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-yaml">uses:
  file-type:
    types:
      File:</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="af68">This is invalid and likely to cause failures.</p>
<h3 id="1cab" class="">Using !include to load the libraries</h3>
<p id="e90c" class="">Since all external files are referenced in RAML by adding the&nbsp;<code>!include</code>&nbsp;tag before the path, it is a common mistake to do the same for when loading external libraries. This is, therefore, invalid:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-yaml">uses:
  file-type: !include file-type.raml</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="6803" class="">The&nbsp;<code>!include</code>&nbsp;tag is not applicable for applying libraries. Instead the library path must be specified directly as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">uses:
  file-type: file-type.raml</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h3 id="9c4e">Composition of Library Namespaces</h3>
<p id="152d" class="">RAML does not allow the composition of namespaces using <code>.</code>&nbsp;across multiple libraries. Developers try to reference types across multiple libraries (files, file-type) as follows which is invalid:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre><code class="language-yaml">type: files.file-type.File</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="3294" class="">Trouble Caused by a Missing Colon ‘:’</h2>
<p id="4fa5">So small and insignificant it is and yet, surprisingly, one of the reasons behind so many failures that developers make. When defining response bodies plenty of developers specify it as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">responses:
  200:
    body:
      application/json</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="1c4c" class="">Do you see the missing colon at the end of&nbsp;<code>application/json</code>? It is what changes the meaning of the whole definition because it implies that the response body is of type&nbsp;<code>application/json</code>&nbsp;i.e.&nbsp;<code>application/json</code>&nbsp;is treated as a string value. Since the types defined in your file will definitely not contain a type named&nbsp;<code>application/json</code>, the file throws an error and fails to convert. To give this value back its original role as a media type/content type name you need to restore the colon as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre><code class="language-yaml">responses:
  200:
    body:
      application/json:</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="0fb8" class="">Now it’s a media type with an empty type declaration which is allowed and won’t cause errors.</p>
<h2 id="baf6">Missing/Invalid Required RAML Version Comment Line</h2>
<p id="cc1b" class="">Relatively less frequent but common, nevertheless, are the issues that developers face when trying to convert their RAML files that do not start with the YAML comment indicating the RAML version. RAML specifications declares them mandatory for both<a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-08/raml-08.md#markup-language">RAML 0.8</a>&nbsp;and<a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/#markup-language">RAML 1.0</a>.</p>
<p id="36bc">For RAML&nbsp;<code>0.8</code>&nbsp;</p>
<p id="36bc">it is specified as:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>#%RAML 0.8</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="4669">For RAML&nbsp;<code>1.0</code>&nbsp;</p>
<p id="4669">it is specified as:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>#%RAML 1.0</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="8ee2" class="">These comment lines are important because they help us distinguish your RAML files from any other YAML files. Also, any other versions specified (like <code>2.0</code>,&nbsp;<code>3.0</code>) are invalid because the only available versions are&nbsp;<code>0.8</code>&nbsp;and&nbsp;<code>1.0</code>. This is, therefore, incorrect:</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>#%RAML 3.0</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="f4c6">Need Array Parameters? Choose RAML 1.0 not 0.8</h2>
<p id="67db" class="">The support for array parameters is available for only request/response body definitions through JSON schema specification. For all other cases (query, header, form or URI parameters) the only available types are:&nbsp;<code>string</code>,&nbsp;<code>number</code>,&nbsp;<code>integer</code>,&nbsp;<code>file</code>,&nbsp;<code>date</code>&nbsp;and&nbsp;<code>boolean</code>. A lot of developers try to use&nbsp;<code>array</code>&nbsp;type for their query parameters which is not supported and in such cases it is recommended to use RAML&nbsp;<code>1.0</code>&nbsp;which has full support for array parameters.</p>
<h2 id="2d55">Incorrect Usage of Primitive Types Available</h2>
<ul class="">
<li>The&nbsp;<code>null</code>&nbsp;type is available as&nbsp;<code>nil</code>&nbsp;in RAML 1.0. A lot of developers still try to use&nbsp;<code>null</code>&nbsp;instead.</li>
<li>The primitive date type available in RAML 0.8 is&nbsp;<code>date</code>&nbsp;while RAML 1.0 offers multiple primitive date types:&nbsp;<code>date-only</code>,&nbsp;<code>time-only</code>,&nbsp;<code>datetime-only</code>,&nbsp;<code>datetime</code>. Developers tend to confuse both and try using&nbsp;<code>date</code>&nbsp;in RAML&nbsp;<code>1.0</code>&nbsp;and&nbsp;<code>date-only</code>&nbsp;in RAML 0.8.</li>
<li>Floating-point numbers are defined by setting <code>type</code>&nbsp;to&nbsp;<code>number</code>&nbsp;and&nbsp;<code>format</code>&nbsp;to&nbsp;<code>float</code>. Developers, however, sometimes try to set type as&nbsp;<code>float</code>&nbsp;directly which is invalid.</li>
</ul>
<h2 id="b66c" class="">Nonconformance to RAML Specification</h2>
<p id="ef8f">Failing to follow the RAML specification in any way may result in failures when using any tool. A property stated to be an object but declared as an array can cause failures. Common mistakes that fall in this category are listed below:</p>
<ul class="">
<li>The<a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-08/raml-08.md#protocols">specification for RAML 0.8</a>&nbsp;states that the&nbsp;<code>protocols</code>&nbsp;property MUST be an array of strings. A lot of developers still declare it as a simple string. Similarly, the<a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/#oauth-20">specification for RAML 1.0</a>&nbsp;declares property&nbsp;<code>scopes</code>&nbsp;as a list of strings and yet plenty of developers declare it as a simple string.</li>
<li>RAML&nbsp;<code>0.8</code>&nbsp;allows named parameters to have multiple types that can be specified as follows:</li>
</ul>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:list /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:list /-->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>file:
  - type: string
  - type: file</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="0a7e">Developers sometimes make the mistake of declaring property&nbsp;<code>type</code>&nbsp;as an array instead which is invalid e.g.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>file:
  type:
    - string
    - file</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="f747">Conclusion</h2>
<p id="a9c9" class="">RAML is a format that comes bundled with plenty of features and with a large feature set comes more complexity. It is very important that the specification documents are detailed, try to cover all cases, and are free from ambiguities. Given the number of mistakes seen above, perhaps there is a need to improve the specifications currently available or a need to increase the number of tooling available for RAML to facilitate users to validate their files and fix potential issues.</p>
<p id="1c15" class="">Have RAML files of your own that you want to convert? Please head over to&nbsp;<a href="https://www.apimatic.io/transformer">Transformer</a> and start converting for free!</p>
<p class="">Thanks to&nbsp;Adeel Ali.&nbsp;</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/common-mistakes-developers-make-in-their-raml-files/">Common Mistakes Developers Make In Their RAML Files</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>From RAML Example Objects to Test Cases</title>
		<link>/blog/from-raml-example-objects-to-test-cases/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Wed, 19 Apr 2017 10:53:45 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[Api Blueprint]]></category>
		<category><![CDATA[Raml]]></category>
		<category><![CDATA[test cases]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=515</guid>

					<description><![CDATA[<p>Machine-readable API descriptions are key enablers of many modern service-oriented activities. Recently, some of the API description formats, including RAML and API Blueprint, have started supporting detailed request and response example objects. If you use such a format then a good news is that APIMatic’s code-gen engine now utilizes your example objects to automatically generate [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/from-raml-example-objects-to-test-cases/">From RAML Example Objects to Test Cases</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="515" class="elementor elementor-515">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-57fea18d elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="57fea18d" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1f5ec332" data-id="1f5ec332" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-7f13c1cf elementor-widget elementor-widget-text-editor" data-id="7f13c1cf" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class="">Machine-readable API descriptions are <a href="https://medium.com/@apimatic/why-your-api-needs-machine-readable-descriptions-4134fff9a419">key enablers</a> of many modern service-oriented activities. Recently, some of the API description formats, including RAML and API Blueprint, have started supporting detailed request and response example objects. If you use such a format then a good news is that APIMatic’s code-gen engine now utilizes your example objects to automatically generate <a href="https://docs.apimatic.io/testing/overview">test cases</a> for your API. That means if you generate an SDK using a RAML file that contains example objects, the SDK will come bundled with test cases for you to test your API, right away.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image size-large">
<p class="mod-reset"><img class="wp-image-516 aligncenter" src="/wp-content/uploads/2021/12/1_fqAUXFupYKrcRqtgqzhKdA.png" alt=""></p>
</figure>
<!-- /wp:image -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="6429" class="">RAML Examples to Test Cases</h2>
<p id="88d3" class="">Both RAML 0.8 and RAML 1.0 support example objects for various resource parameters (query parameters, URI parameters, body parameters, and form parameters). You can specify example value for these using the “example” property, whereas, in RAML 1.0, multiple examples can be specified. Similarly, example objects for the possible responses from a resource can also be specified using the “example/examples” property. The request example values and the expected response values can be utilized for testing purposes if you use APIMatic to import these API Description files. Example values for all required parameters must be present for successful generation of the test case for any particular resource.</p>
<p id="b4a9" class="">Let’s take you through a brief journey of how you can specify various example values in RAML 0.8 and RAML 1.0 both. For better understanding, I will be using Calculator API for my illustration below.</p>
<h2 id="779b">Specifying Resource Parameter Values</h2>
<h3 id="88c3" class="">RAML 0.8</h3>
<p id="5d5d">The following code snippet has values to two different parameters. SUM value has been assigned to URI parameter “operation”, whereas 2 and 3 have been assigned to query parameters “x” and “y” respectively.</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:heading /-->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">#%RAML 0.8
title: Calculator
version: 1.0
documentation:
- title: Calculator
content: Simple Calculator API
baseUri: https://examples.devapi.dream.press/apps/calculator
baseUriParameters: {}
/{operation}:
uriParameters:
operation:
description: ‘’
example: SUM
required: true
displayName: operation
enum:
- SUM
- SUBTRACT
- MULTIPLY
- DIVIDE
get:
displayName: Calculate
description: Calculates the expression based on the x and y operator
responses:
200:
description: Success
example: 5
queryParameters:
x:
description: ‘’
type: number
example: 2
required: true
displayName: x
y:
description: ‘’
type: number
example: 3
required: true
displayName: y</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="cb6a">Once your parameter values have been specified, we can then automatically generate test cases out of them. Under RAML 0.8, if multiple values are provided, then APIMatic will utilize the first provided values by default.</p>
<h3 id="b0bf">RAML 1.0</h3>
<p id="8584" class="">Here, you have the ability to define multiple examples instead of a single example using the “examples” property. Each example object has a unique identifier that identifies the example. The “example” property is definitely valid in RAML 1.0 too but you can either use the “example” property or the “examples” property but not both. Observe the following snippet and see how “examples” property has been used to generate test case.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">get:
description: Returns an organization entity.
responses:
201:
body:
application/json:
type: Org
examples:
acme:
name: Acme
softwareCorp:
value: # validate against the available facets for the map value of an example
name: Software Corp
address: 35 Central Street
value: Gold # validate against an instance of the `value` property</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="70e4" class="">You can find more details on how to specify examples in RAML 1.0 at&nbsp;<a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/#defining-examples-in-raml">https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/#defining-examples-in-raml</a></p>
<h2 id="5c43">Specifying Expected Response Headers</h2>
<p id="a232" class="">You can also specify response headers and their example values which can be utilized as the expected values for response headers in the generated test cases. Here an example value for header “<code>Location</code>” is “<code>/invoices/45612</code>”</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">post:
body:
type: Invoice
responses:
201:
headers:
Location:
example: /invoices/45612</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="920b">Note to Self!</h2>
<p id="06cb" class="">You don’t need to go through the hassle of specifying test cases for your API yourself. We will simply bring your example objects into use in order to create them. For more information, visit our <a href="https://docs.apimatic.io/testing/overview">website</a> where complete documentation on the test case is already present for you to successfully run your test cases!</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/from-raml-example-objects-to-test-cases/">From RAML Example Objects to Test Cases</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Introducing New Supported Formats: RAML 1.0, Postman 2.0</title>
		<link>/blog/introducing-new-supported-formats-raml-1-0-postman-2-0/</link>
		
		<dc:creator><![CDATA[Faria Rehman]]></dc:creator>
		<pubDate>Fri, 25 Nov 2016 10:53:46 +0000</pubDate>
				<category><![CDATA[Blog]]></category>
		<category><![CDATA[Api Description]]></category>
		<category><![CDATA[API Transformer]]></category>
		<category><![CDATA[Apimatic Features]]></category>
		<category><![CDATA[Postman]]></category>
		<category><![CDATA[Raml]]></category>
		<guid isPermaLink="false">https://devapi.dream.press/?p=469</guid>

					<description><![CDATA[<p>The wait is over! We have added RAML 1.0 and Postman 2.0 to our list of &#160;supported API formats. So grab your RAML 1.0 or Postman 2.0 APIs and start converting them to other formats of your choice or convert your existing APIs to these new formats. Unlike before, you can now also convert your [&#8230;]</p>
<p>The post <a rel="nofollow" href="/blog/introducing-new-supported-formats-raml-1-0-postman-2-0/">Introducing New Supported Formats: RAML 1.0, Postman 2.0</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="469" class="elementor elementor-469">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-22a9c99d elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="22a9c99d" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-3452a568" data-id="3452a568" data-element_type="column">
			<div class="elementor-widget-wrap elementor-element-populated">
								<div class="elementor-element elementor-element-b371405 elementor-widget elementor-widget-text-editor" data-id="b371405" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
							<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="f95e" class="">The wait is over! We have added RAML 1.0 and Postman 2.0 to our list of &nbsp;supported API formats. So grab your RAML 1.0 or Postman 2.0 APIs and start converting them to other formats of your choice or convert your existing APIs to these new formats. Unlike before, you can now also convert your APIs to Postman 1.0.</p>
<p id="03ae" class="">For this blog, we will be using the APIMatic Calculator API description file as an example. You can grab this file when you export this API from the APIMatic Dashboard to APIMATIC format.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:paragraph /-->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="alignnone wp-image-470" src="/wp-content/uploads/2021/12/1__9vtGsvibJsI-8DJ9T9TmA.png" alt="APIMatic now supports API Formats RAML 1.0, Postman 2.0  " width="348" height="399"></p>
<figcaption>Export API Description</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:heading -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<h2 id="cad9" class="">RAML 1.0</h2>
<p id="2b03" class="">You can import your RAML 1.0 APIs from the Dashboard or you can use our Transformer to convert RAML 1.0 files to other supported API formats. You can even generate RAML 1.0 files from APIs in other API formats using the Transformer.</p>
<p id="ae17">Navigate to the Transformer and using the Calculator API convert it to RAML 1.0 as follows:</p>
</div>
</div>
</div>
</div>
<!-- /wp:heading -->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="alignnone wp-image-471" src="/wp-content/uploads/2021/12/1_GVnuShzdGUdth4cBFAfDnQ.png" alt="API Conversion" width="700" height="441"></p>
<figcaption>API Conversion</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="a871" class="">After successful conversion, you will get your converted file in RAML 1.0 format.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="wp-image-472" src="/wp-content/uploads/2021/12/1_HEea_w9CtqEk_gJ4lWN7ng.png" alt=""></p>
<figcaption>API Transformer</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:preformatted -->
<pre class=""><code class="language-yaml">#%RAML 1.0
title: APIMATIC Calculator
version: 1.0
baseUri: http://examples.devapi.dream.press/apps/calculator
documentation:
- title: APIMATIC Calculator
content: Simple calculator API hosted on APIMATIC
/{operation}:
get:
 displayName: Calculate
 description: Calculates the expression using the specified  
 operation.
 queryParameters:
    x:
     required: true
     displayName: x
     description: The LHS value
     type: number
     format: double
    y:
     required: true
     displayName: y
     description: The RHS value
     type: number
     format: double
    responses:
     200:
    description: Success
    body:
     text/plain:
      displayName: response
      type: number
      format: double
    uriParameters:
     operation:
      required: true
      displayName: operation
      description: The operator to apply on the variables
      type: string
      enum:
      - SUM
      - SUBTRACT
      - MULTIPLY
      - DIVIDE</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="7d07">You can also convert from RAML 1.0 back to other formats as required.</p>
<h2 id="db8d" class="">Postman</h2>
<p id="3aa4" class="">You can now convert back and forth from Postman 2.0 files. Support for converting from Postman 1.0 to other formats has been there for a while. But now we offer support for Postman 1.0 export as well. You can import your Postman 2.0 APIs from the Dashboard or you can use our <a href="https://docs.devapi.dream.press/api-transformer/overview-transformer">Transformer</a> to convert Postman 2.0 files to other supported formats.</p>
<p id="fb60" class="">Go to Transformer and convert your Calculator API to Postman 1.0 or Postman 2.0 as per your choice. For our example we will be converting to Postman 2.0.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:heading /-->

<!-- wp:paragraph /-->

<!-- wp:paragraph /-->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="wp-image-474" src="/wp-content/uploads/2021/12/1_9PNn2GIzIZ4pDdU27gE9uw.png" alt=""></p>
<figcaption>API Conversion in Postman</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="c7b2">After successful conversion, you will get your converted file in Postman 2.0 format</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class=""><code class="language-json">{
  &quot;info&quot;: {
    &quot;name&quot;: &quot;APIMATIC Calculator&quot;,
    &quot;_postman_id&quot;: &quot;a2022ecc-bc18–42bc-9fd4-ccd964606911&quot;,
    &quot;description&quot;: &quot;Simple calculator API hosted on APIMATIC&quot;,
    &quot;schema&quot;: &quot;https://schema.getpostman.com/json/collection/v2.0.0/&quot;
  },
  &quot;item&quot;: [
    {
      &quot;name&quot;: &quot;Simple Calculator&quot;,
      &quot;item&quot;: [
        {
          &quot;id&quot;: &quot;e95fc07e-85eb-40f3-a59a-99e57a808c0e&quot;,
          &quot;name&quot;: &quot;Calculate&quot;,
          &quot;request&quot;: {
            &quot;url&quot;: {
              &quot;protocol&quot;: &quot;http&quot;,
              &quot;host&quot;: &quot;examples.devapi.dream.press&quot;,
              &quot;path&quot;: [
                &quot;apps&quot;,
                &quot;calculator&quot;,
                &quot;:operation&quot;
              ],
              &quot;port&quot;: &quot;80&quot;,
              &quot;query&quot;: [
                {
                  &quot;key&quot;: &quot;x&quot;,
                  &quot;value&quot;: &quot;undefined&quot;
                },
                {
                  &quot;key&quot;: &quot;y&quot;,
                  &quot;value&quot;: &quot;undefined&quot;
                }
              ],
              &quot;variable&quot;: [
                {
                  &quot;id&quot;: &quot;operation&quot;,
                  &quot;value&quot;: &quot;&quot;
                }
              ]
            },
            &quot;method&quot;: &quot;GET&quot;,
            &quot;body&quot;: {
              &quot;mode&quot;: &quot;raw&quot;
            }
          },
          &quot;response&quot;: [
            {
              &quot;code&quot;: 200
            }
          ]}]}]}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="c378">You can directly import this file into your Postman app.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="wp-image-476" src="/wp-content/uploads/2021/12/1_kdKijfORq8rs8iIVibfgMg.png" alt=""></p>
<figcaption>Postman App</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p id="6598" class="">After successful conversion, you will get your converted file in RAML 1.0 format.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->

<!-- wp:image -->
<div class="wp-block-image">
<figure class="aligncenter size-large">
<p class="mod-reset"><img class="wp-image-477" src="/wp-content/uploads/2021/12/1_3ecP0GAtLc-LKTGTycd2wg.png" alt=""></p>
<figcaption>Postman App</figcaption>
</figure>
</div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<div class="boldgrid-section">
<div class="container">
<div class="row">
<div class="col-md-12 col-xs-12 col-sm-12">
<p class="">Do you have an APIMatic API definition that also includes test cases? Good news! Exporting to Postman will create completely ready-to-test collection of requests.</p>
</div>
</div>
</div>
</div>
<!-- /wp:paragraph -->						</div>
				</div>
					</div>
		</div>
							</div>
		</section>
							</div>
		<p>The post <a rel="nofollow" href="/blog/introducing-new-supported-formats-raml-1-0-postman-2-0/">Introducing New Supported Formats: RAML 1.0, Postman 2.0</a> appeared first on <a rel="nofollow" href="/">APIMatic</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
